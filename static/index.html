<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nils&#39; RPG</title>
<link rel="icon" href="/favicon.ico" sizes="any" />
<style>
  :root { --bg:#0f1117; --card:#161a22; --muted:#8b93a7; --fg:#e6e9ef; --accent:#7aa2f7; --accent2:#89dceb; --bad:#f7768e; --ok:#9ece6a; --warn:#e0af68; }
  /* FX saver mode: kill blur/translucency that can break cursor compositing on some GPUs */
  :root.nofx * {
    -webkit-backdrop-filter: none !important;
    backdrop-filter: none !important;
    filter: none !important;
    box-shadow: none !important;
  }
  * { box-sizing: border-box; }
  body { margin:0; font-family: system-ui,Segoe UI,Roboto,Arial,sans-serif; min-height:100vh; background: var(--bg); color: var(--fg); }
  body.join-screen {
    background-color: var(--bg);
    background-image: var(--join-screen-bg, url("/static/img/dungeon-gate.png"));
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }
  body.join-screen #btnNextTurn { display: none; }
  header { display:grid; grid-template-columns: 1fr auto 1fr; align-items:center; padding: 12px 16px; border-bottom:1px solid #222736; position: sticky; top:0; background: rgba(15,17,23,0.9); backdrop-filter: blur(6px); column-gap:16px; }
  header h1 { margin:0; font-size: 18px; letter-spacing:.5px; display:flex; align-items:center; gap:12px; }
  .header-left { justify-self:start; }
  .header-center, .header-right { display:flex; align-items:center; min-width:0; }
  .header-center { justify-self:center; justify-content:center; gap:12px; }
  .header-right { justify-self:end; justify-content:flex-end; gap:10px; flex-wrap:wrap; }
  .turn-display { font-size:14px; }
  button, select, input, textarea { background: var(--card); color: var(--fg); border:1px solid #262c3a; border-radius:8px; padding:8px 10px; }
  textarea { resize: vertical; }
  button { cursor:pointer; }
  button[disabled] { opacity:.5; cursor:not-allowed; }
  .wrap { display:flex; gap:16px; padding:16px; }
  .col { display:flex; flex-direction:column; gap:16px; flex:1; min-width:280px; min-height:0; }
  .card { background: var(--card); border:1px solid #262c3a; border-radius:12px; padding:14px; }
  .card[draggable="true"] { cursor: grab; }
  .card.dragging { opacity: .6; }
  .panel-header { justify-content:space-between; margin-bottom:8px; }
  .mini-toggle { font-size:12px; padding:4px 10px; border-radius:999px; line-height:1; border:1px solid #262c3a; background:var(--card); color:var(--muted); transition:color .2s ease, border-color .2s ease, background .2s ease; }
  .mini-toggle[aria-pressed="true"], .mini-toggle.active { color:var(--accent); border-color:var(--accent); background:rgba(122,162,247,0.14); }
  .mini-toggle:disabled { opacity:0.5; cursor:not-allowed; }
  .system-notice { display:none; margin:8px 16px 0; padding:10px 14px; border-radius:10px; font-size:13px; line-height:1.4; border:1px solid transparent; background:rgba(122,162,247,0.12); color:var(--accent); }
  .system-notice.info { background:rgba(122,162,247,0.12); border-color:rgba(122,162,247,0.32); color:var(--accent2); }
  .system-notice.error { background:rgba(247,118,142,0.14); border-color:rgba(247,118,142,0.4); color:var(--bad); }
  .col.drag-target { outline: 1px dashed var(--accent2); }
  .lane-drop { border:1px dashed #262c3a; border-radius:12px; min-height:120px; display:flex; align-items:center; justify-content:center; padding:14px; color: var(--muted); font-size:14px; }
  .lane-drop.drag-target { border-color: var(--accent2); color: var(--accent2); }
  .muted { color: var(--muted); }
  .hidden { display:none; }
  .form-card .world-custom-input { width:100%; }
  .world-style-picker { position:relative; display:flex; flex-direction:column; gap:6px; }
  .world-style-trigger { display:flex; align-items:center; justify-content:space-between; gap:12px; width:100%; background:var(--card); color:var(--fg); border:1px solid #262c3a; border-radius:8px; padding:8px 10px; cursor:pointer; font:inherit; text-align:left; }
  .world-style-trigger:hover, .world-style-trigger:focus-visible { border-color:rgba(137,220,235,0.45); color:var(--accent2); outline:none; }
  .world-style-trigger::after { content:"v"; font-size:11px; color:var(--muted); transition:transform .14s ease; }
  .world-style-trigger[aria-expanded="true"]::after { transform:rotate(180deg); }
  .world-style-menu { position:absolute; top:calc(100% + 6px); left:0; right:0; background:rgba(21,24,33,0.96); border:1px solid #262c3a; border-radius:12px; box-shadow:0 18px 32px rgba(5,7,13,0.55); max-height:260px; overflow-y:auto; padding:6px; display:flex; flex-direction:column; gap:4px; z-index:40; }
  .world-style-menu.hidden { display:none; }
  .world-style-option { display:flex; align-items:center; gap:10px; justify-content:flex-start; width:100%; padding:6px 10px; border-radius:10px; border:1px solid transparent; background:transparent; color:var(--fg); cursor:pointer; font:inherit; text-align:left; transition:all .12s ease; }
  .world-style-option:hover, .world-style-option:focus-visible { border-color:rgba(137,220,235,0.3); background:rgba(137,220,235,0.12); outline:none; }
  .world-style-option[data-selected="true"] { border-color:var(--accent2); background:rgba(137,220,235,0.18); }
  .world-style-option.level-0 { font-weight:600; }
  .world-style-option.level-1 { font-weight:500; }
  .world-style-option.level-2 { font-size:13px; }
  .world-style-option.level-3 { font-size:12px; }
  .world-style-hint { margin-left:auto; font-size:11px; color:var(--muted); }
  .world-style-group { display:flex; flex-direction:column; gap:4px; }
  .world-style-group-header { display:flex; align-items:center; gap:6px; padding:2px 4px; border-radius:10px; }
  .world-style-group-header:hover { background:rgba(137,220,235,0.06); }
  .world-style-group-header .world-style-option { flex:1; padding:6px 8px; }
  .world-style-expander { width:24px; height:24px; display:grid; place-items:center; border-radius:6px; border:1px solid transparent; background:transparent; color:var(--muted); cursor:pointer; font-size:12px; }
  .world-style-expander:hover, .world-style-expander:focus-visible { border-color:rgba(137,220,235,0.3); color:var(--accent2); outline:none; }
  .world-style-children { display:flex; flex-direction:column; gap:4px; margin-left:16px; }
  .world-style-children.hidden { display:none; }
  .join-layout { flex:none; width: min(720px, 100%); position:absolute; top:8vh; left:50%; transform:translateX(-50%); z-index:20; }
  .join-layout.dragging { cursor:grabbing; }
  .join-card { position:relative; overflow:hidden; padding:26px; background:linear-gradient(165deg, rgba(22,26,34,0.94), rgba(16,20,28,0.98)); border:1px solid rgba(122,162,247,0.2); box-shadow:0 28px 50px rgba(4,6,12,0.55); backdrop-filter: blur(12px); display:flex; flex-direction:column; gap:24px; border-radius:18px; }
  .join-card-link { position:absolute; top:10px; right:14px; font-size:10px; color:var(--muted); text-decoration:none; letter-spacing:0.3px; opacity:0.8; }
  .join-card-link:hover, .join-card-link:focus-visible { color:var(--accent2); opacity:1; text-decoration:underline; outline:none; }
  .join-card::before { content:""; position:absolute; inset:0; border-radius:inherit; pointer-events:none; border:1px solid rgba(137,220,235,0.25); opacity:0.35; }
  .join-card-header { display:flex; gap:18px; align-items:flex-start; cursor:grab; user-select:none; touch-action:none; }
  .join-layout.dragging .join-card-header { cursor:grabbing; }
  .join-emblem { width:58px; height:58px; border-radius:18px; background:linear-gradient(140deg, rgba(122,162,247,0.32), rgba(137,220,235,0.18)); border:1px solid rgba(122,162,247,0.4); box-shadow:0 12px 28px rgba(11,15,24,0.8); position:relative; }
  .join-emblem::after, .join-emblem::before { content:""; position:absolute; border-radius:999px; background:rgba(230,233,239,0.85); }
  .join-emblem::before { width:4px; height:32px; top:13px; left:27px; opacity:0.45; }
  .join-emblem::after { width:32px; height:4px; top:27px; left:13px; opacity:0.45; }
  .join-eyebrow { display:inline-flex; text-transform:uppercase; letter-spacing:0.18em; font-size:11px; color:rgba(137,220,235,0.85); margin-bottom:4px; }
  .join-subtitle { margin:6px 0 0 0; font-size:14px; color:rgba(230,233,239,0.78); line-height:1.5; }
  .join-form { gap:18px; }
  .join-label { font-size:13px; color:rgba(230,233,239,0.78); display:flex; flex-direction:column; gap:8px; }
  #joinView input, #joinView textarea { width:100%; background:rgba(19,23,33,0.85); border:1px solid rgba(122,162,247,0.18); border-radius:10px; padding:12px 14px; transition:border-color .2s ease, box-shadow .2s ease, transform .15s ease; font-size:15px; }
  #joinView input:focus, #joinView textarea:focus { outline:none; border-color:rgba(137,220,235,0.65); box-shadow:0 0 0 3px rgba(122,162,247,0.2); transform:translateY(-1px); }
  #joinView textarea { min-height:72px; resize:vertical; }
  .join-primary { background:linear-gradient(120deg, rgba(122,162,247,0.95) 0%, rgba(137,220,235,0.95) 100%); color:#0b0d13; border:none; border-radius:999px; padding:14px 18px; font-size:15px; font-weight:600; box-shadow:0 24px 32px rgba(8,11,20,0.55), 0 0 0 1px rgba(137,220,235,0.35); transition:transform .15s ease, box-shadow .2s ease; }
  .join-primary:hover { transform:translateY(-1px); box-shadow:0 18px 28px rgba(12,16,25,0.6), 0 0 0 1px rgba(137,220,235,0.45); }
  .join-primary:active { transform:translateY(0); box-shadow:0 12px 20px rgba(12,16,25,0.55), 0 0 0 1px rgba(137,220,235,0.4); }
  .join-hint, .join-status { font-size:12px; color:rgba(139,147,167,0.9); line-height:1.5; }
  .join-status { border-left:2px solid rgba(137,220,235,0.3); padding-left:10px; margin:0; }
  @media (max-width: 640px) {
    .join-layout { margin:5vh auto; padding:0 12px; }
    .join-card { padding:22px; }
    .join-card-header { flex-direction:column; align-items:flex-start; }
  .join-emblem { width:52px; height:52px; border-radius:16px; }
    .join-emblem::before { top:12px; left:24px; height:28px; }
    .join-emblem::after { top:24px; left:12px; width:28px; }
  }
  .row { display:flex; gap:10px; align-items:center; }
  .fullscreen-hint { font-size:11px; color:var(--muted); white-space:pre-line; margin-left:4px; line-height:1.2; }
  .right { margin-left:auto; }
  .card[data-pane-id="narrative"] { display:flex; flex-direction:column; }
  #narrative {
    /* Narrative auto-height: fill column while keeping 6 lines minimum */
    white-space:pre-wrap;
    line-height:1.4;
    overflow-y:auto;
    padding-right:6px;
    max-height:none;
    min-height:calc(6lh);
    flex:1 1 auto;
  }
  .narrative-block { white-space:pre-wrap; margin:0 0 12px; padding-bottom:12px; border-bottom:1px solid rgba(122,162,247,0.2); }
  .narrative-block:last-child { margin-bottom:0; padding-bottom:0; border-bottom:none; }
  @keyframes blinkCursor { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
  #players li { display:flex; align-items:flex-start; gap:12px; padding:6px 0; border-bottom:1px dashed #222736; }
  #players li:last-child { border-bottom: none; }
  .player-main { display:flex; align-items:center; gap:12px; flex:1; min-width:0; }
  .player-portrait { width:40px; height:40px; border-radius:10px; border:1px solid #283048; background:#131722; display:flex; align-items:center; justify-content:center; font-size:15px; font-weight:600; color: var(--muted); overflow:hidden; cursor:pointer; padding:0; transition: border-color .2s ease, color .2s ease; }
  .player-portrait.has-image { background-size:cover; background-position:center; color:transparent; }
  .player-portrait[data-clickable="false"] { cursor:default; opacity:0.6; border-color:#222736; }
  .player-portrait[data-clickable="true"]:hover { border-color: var(--accent2); color: var(--accent2); }
  .portrait-preview { position:fixed; z-index:9999; display:none; pointer-events:none; border:1px solid rgba(137,220,235,0.7); border-radius:12px; background: rgba(10,12,19,0.92); box-shadow:0 18px 48px rgba(0,0,0,0.45); padding:12px; max-width:min(520px, 60vw); max-height:min(640px, 70vh); overflow:auto; }
  .portrait-preview img { display:block; width:100%; height:auto; border-radius:8px; }
  .portrait-preview .portrait-preview-turnaround { margin-top:12px; }
  .pill { padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #2a3142; }
  .player-status { display:inline-flex; align-items:center; white-space:nowrap; }
  .good { color: var(--ok); border-color: var(--ok); }
  .warn { color: var(--warn); border-color: var(--warn); }
  .bad { color: var(--bad); border-color: var(--bad); }
  .stack { display:flex; flex-direction:column; gap:8px; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  img#scene { width:100%; border-radius:10px; border:1px solid #262c3a; }
  video#sceneVideo { width:100%; border-radius:10px; border:1px solid #262c3a; background:#000; }
  .scene-actions { display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
  .player-name { display:flex; flex-direction:column; gap:4px; min-width:0; }
  .player-name-row { display:flex; align-items:flex-start; gap:8px; min-width:0; }
  .player-name-main { font-weight:600; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .player-class { font-size: 13px; color: var(--muted); }
  .player-action { flex:1; min-width:0; font-size:13px; color: var(--muted); margin-left:8px; overflow-wrap:anywhere; }
  .player-action.has-submission { color: var(--fg); }
  .player-tags { display:flex; flex-wrap:wrap; gap:6px; }
  .list-note { list-style:none; font-size:12px; color: var(--muted); padding-left:0; margin-left:0; }
  .list-note::marker { content:""; }
  .list-added { color: var(--ok); }
  .list-removed { color: var(--bad); text-decoration: line-through; }
  /* Modal */
  .modalBack { position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; }
  .modal { width:min(720px, 92vw); background: var(--card); border:1px solid #2a3142; border-radius:12px; padding:16px; }
  .modal h3 { margin-top:0; }
  .modal.dev-info-modal { width:calc(100vw - 24px); max-width:calc(100vw - 24px); height:calc(100vh - 24px); max-height:calc(100vh - 24px); display:flex; flex-direction:column; padding:20px; overflow:hidden; }
  .dev-info-grid { display:flex; flex-direction:row; gap:16px; flex:1 1 auto; flex-wrap:nowrap; align-items:stretch; min-height:0; width:100%; }
  .dev-info-section { background:rgba(18,22,32,0.95); border:1px solid #1f2534; border-radius:10px; padding:12px; flex:1 1 0%; min-width:320px; min-width:0; display:flex; flex-direction:column; min-height:0; height:100%; overflow:hidden; }
  .dev-info-section h4 { margin:0 0 8px; font-size:14px; letter-spacing:0.04em; text-transform:uppercase; color:var(--muted); }
  .dev-info-pre { margin:0; background:rgba(12,16,24,0.92); border:1px solid #262c3a; border-radius:8px; padding:12px; flex:1 1 0%; overflow-y:scroll; overflow-x:auto; min-height:0; min-width:0; width:100%; height:100%; font-family:"JetBrains Mono", Consolas, "SFMono-Regular", monospace; font-size:13px; line-height:1.45; white-space:pre-wrap; word-break:break-word; scrollbar-gutter:stable; }
  .tip { font-size: 12px; color: var(--muted); }
  .tooltip { border-bottom:1px dashed var(--muted); cursor:help; }
  .stats-summary { display:flex; flex-wrap:wrap; gap:12px; margin-bottom:16px; }
  .stat-chip { flex:1 1 160px; background: linear-gradient(135deg, rgba(122,162,247,0.15), rgba(137,220,235,0.08)); border:1px solid #283048; border-radius:10px; padding:12px 14px; }
  .stat-chip-label { font-size:12px; letter-spacing:0.05em; text-transform:uppercase; color: var(--muted); display:block; margin-bottom:6px; }
  .stat-chip-value { font-size:22px; font-weight:600; color: var(--fg); }
  .stats-actions { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:16px; }
  .stats-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:16px; }
  .stat-card { background: var(--card); border:1px solid #1f2534; border-radius:10px; padding:12px 14px; box-shadow:0 4px 12px rgba(0,0,0,0.18); }
  .stat-label { font-size:12px; letter-spacing:0.04em; text-transform:uppercase; color: var(--muted); margin-bottom:6px; display:block; }
  .stat-value { font-size:18px; font-weight:500; color: var(--fg); }
  .empty-state { font-size:14px; color: var(--muted); margin:16px 0; }
  .settings-modal { padding:0; background: radial-gradient(circle at top left, rgba(122,162,247,0.16), rgba(15,17,23,0.9)); border:1px solid #283048; box-shadow:0 28px 60px rgba(0,0,0,0.45); overflow:hidden; }
  .settings-header { display:flex; align-items:flex-start; justify-content:space-between; padding:24px 28px 20px; background: linear-gradient(135deg, rgba(21,25,35,0.95), rgba(13,15,22,0.92)); border-bottom:1px solid #1f2534; }
  .settings-header h3 { margin:0; font-size:22px; }
  .settings-header .tip { margin:6px 0 0; font-size:13px; }
  .icon-button { width:36px; height:36px; display:grid; place-items:center; border-radius:50%; padding:0; border:1px solid transparent; background:rgba(122,162,247,0.08); color: var(--muted); font-size:20px; cursor:pointer; transition:all .15s ease; }
  .icon-button:hover { color: var(--fg); border-color:rgba(122,162,247,0.45); background:rgba(122,162,247,0.18); }
  .settings-body { padding:24px 28px; display:flex; flex-direction:column; gap:20px; max-height:65vh; overflow-y:auto; backdrop-filter: blur(4px); }
  .form-card { background: rgba(21,24,33,0.86); border:1px solid #242c3c; border-radius:14px; padding:20px; box-shadow:0 14px 32px rgba(0,0,0,0.25); display:flex; flex-direction:column; gap:16px; }
  .form-card h4 { margin:0; font-size:15px; letter-spacing:0.08em; text-transform:uppercase; color: var(--muted); }
  .form-card label { font-size:14px; font-weight:500; color: var(--fg); display:flex; flex-direction:column; gap:6px; }
  .form-card .tip { margin-top:2px; }
  .settings-body .grid2 { gap:16px; }
  .settings-footer { padding:16px 28px 24px; border-top:1px solid #1f2534; background: rgba(15,17,23,0.92); display:flex; flex-wrap:wrap; gap:16px; align-items:center; }
  .video-length-control { display:flex; flex-direction:column; gap:8px; }
  .video-length-input { display:flex; align-items:center; gap:8px; }
  .video-length-input input[type="number"] { width:90px; }
  .video-length-suffix { color: var(--muted); font-size:13px; }
  .share-chip { display:flex; flex-direction:column; gap:6px; background: rgba(122,162,247,0.12); border:1px solid rgba(122,162,247,0.35); border-radius:12px; padding:12px 16px; min-width:240px; }
  .share-chip span { font-size:12px; letter-spacing:0.06em; text-transform:uppercase; color: var(--muted); }
  .share-chip code { font-family: "JetBrains Mono", Consolas, "SFMono-Regular", monospace; font-size:13px; color: var(--accent2); background: rgba(10,12,19,0.6); border-radius:8px; padding:4px 8px; word-break: break-word; }
  button.primary { background: linear-gradient(135deg, rgba(122,162,247,0.95), rgba(137,220,235,0.85)); border-color: rgba(137,220,235,0.4); color:#05070d; font-weight:600; padding:10px 20px; box-shadow:0 16px 32px rgba(122,162,247,0.35); transition: transform .15s ease, box-shadow .15s ease; }
  button.primary:hover { transform: translateY(-1px); box-shadow:0 20px 38px rgba(122,162,247,0.45); }
  button.primary:active { transform: translateY(0); box-shadow:0 12px 26px rgba(122,162,247,0.3); }
  .settings-footer button.primary { margin-left:auto; }
  @media (max-width: 640px) {
    .settings-header, .settings-body, .settings-footer { padding-left:20px; padding-right:20px; }
    .settings-body { max-height:70vh; }
  }
</style>
</head>
<body>
<header>
  <div class="header-left">
    <h1>Nils&#39; RPG <span id="turnHeader" class="turn-display muted">Turn 0</span></h1>
  </div>
  <div class="header-center">
    <button id="btnNextTurn" data-i18n="game.nextTurn">Next turn</button>
  </div>
  <div class="header-right">
    <span id="lockBanner" class="muted"></span>
    <button id="btnStats" data-i18n="header.stats">Statistics</button>
    <button id="btnDevInfo" data-i18n="header.devInfo">Developer info</button>
    <button id="btnSettings" data-i18n="header.settings">Settings</button>
    <select id="languageSelect" aria-label="Language" data-i18n-attr="aria-label:language.label">
      <option value="en" data-i18n-option="language.option.english">English</option>
      <option value="de" data-i18n-option="language.option.german">Deutsch</option>
    </select>
    <span id="fullscreenHint" class="fullscreen-hint" data-i18n="header.fullscreenHint">Press
F11</span>
  </div>
</header>

<div id="systemNotice" class="system-notice info" role="status" aria-live="polite"></div>

<main class="wrap" data-pane-board="true">
  <!-- Join screen -->
  <section id="joinView" class="col join-layout">
    <div class="card join-card">
      <a class="join-card-link" href="https://suno.com/s/CTdevHgPjlr6LIdv" target="_blank" rel="noopener noreferrer">Song by Suno</a>
      <div class="join-card-header">
        <div class="join-emblem" aria-hidden="true"></div>
        <div>
          <span class="join-eyebrow" data-i18n="join.eyebrow">Session Zero</span>
          <h3 data-i18n="join.title">Forge your legend</h3>
          <p class="join-subtitle" data-i18n="join.subtitle">Sketch a name and origin so the game master can welcome your hero into the story.</p>
        </div>
      </div>
      <div class="stack join-form">
        <label class="join-label">
          <span data-i18n="join.nameLabel">Character name</span>
          <input id="name" placeholder="Hephaest" value="Hephaest" data-i18n-attr="placeholder:join.namePlaceholder" />
        </label>
        <label class="join-label">
          <span data-i18n="join.backgroundLabel">Short background (2–3 sentences)</span>
          <textarea id="background" rows="3" placeholder="Wizard" data-i18n-attr="placeholder:join.backgroundPlaceholder">Wizard</textarea>
        </label>
        <button id="btnEnter" class="join-primary" data-i18n="join.enter">Enter World</button>
        <p id="joinHint" class="tip join-hint" data-i18n="join.hintWaiting">You'll start right away if no adventure is running; otherwise you'll appear after the next turn resolves.</p>
        <p id="joinStatus" class="tip join-status" style="display:none"></p>
      </div>
    </div>
  </section>

  <!-- Game screen -->
  <section id="gameView" class="col" data-pane-group="main" style="display:none">
    <div class="card" data-pane-id="players">
      <h3 style="margin:0 0 8px 0" data-i18n="sidebar.players">Players</h3>
      <ul id="players" style="list-style:none; padding:0; margin:0"></ul>
    </div>

    <div class="card" data-pane-id="character">
      <h3 style="margin:0 0 8px 0" data-i18n="sidebar.yourCharacter">Your character</h3>
      <div id="you" class="stack">
        <div id="youFlags" class="player-tags"></div>
        <div class="grid2">
          <div>
            <div class="muted" data-i18n="sidebar.abilities">Abilities</div>
            <ul id="youAbilities" style="margin:0; padding-left:18px"></ul>
          </div>
          <div>
            <div class="muted" data-i18n="sidebar.inventory">Inventory</div>
            <ul id="youInv" style="margin:0; padding-left:18px"></ul>
          </div>
        </div>
        <div>
          <div class="muted" data-i18n="sidebar.conditions">Conditions</div>
          <ul id="youCond" style="margin:0; padding-left:18px"></ul>
        </div>
      </div>
    </div>

    <div class="card" data-pane-id="narrative">
      <div class="row panel-header">
        <h3 style="margin:0" data-i18n="game.narrative">Narrative</h3>
        <button id="btnNarration" type="button" class="mini-toggle" aria-pressed="false" title="Toggle ElevenLabs narration" data-i18n="game.narrateOff">Narrate Off</button>
      </div>
      <div id="narrative" class="muted">Waiting…</div>
    </div>

    <div class="card" data-pane-id="actions">
      <h3 style="margin:0 0 8px 0" data-i18n="game.actions">Actions</h3>
      <div class="stack">
        <textarea id="action" rows="3" placeholder="What do you attempt to do?" data-i18n-attr="placeholder:game.actionPlaceholder"></textarea>
        <button id="btnSubmit" hidden aria-hidden="true" tabindex="-1" data-i18n="game.submit">Submit</button>
      </div>
    </div>
  </section>

  <!-- Sidebar -->
  <aside id="side" class="col" data-pane-group="sidebar" style="display:none">
    <div class="card" data-pane-id="scene">
      <div class="row panel-header scene-header">
        <h3 style="margin:0" data-i18n="sidebar.sceneImage">Scene image</h3>
        <div class="scene-actions">
          <button id="btnCreateImage" type="button" class="mini-toggle" aria-pressed="false" title="Enable automatic scene images" data-i18n="sidebar.autoImageOff">Auto Image Off</button>
          <button id="btnAnimateImage" type="button" class="mini-toggle hidden" title="Animate the current scene image" data-i18n="sidebar.animateImage" data-i18n-attr="title:sidebar.animateImageTitle">Animate Image</button>
          <button id="btnAnimateScene" type="button" class="mini-toggle" aria-pressed="false" title="Enable automatic scene animations" data-i18n="sidebar.autoVideoOff">Auto Animation Off</button>
        </div>
      </div>
      <video id="sceneVideo" class="hidden" preload="metadata" playsinline loop controls autoplay></video>
      <img id="scene" style="display:none" title="" />
    </div>
  </aside>
</main>

<!-- Settings modal -->
<div id="settingsBack" class="modalBack">
  <div class="modal settings-modal">
    <div class="settings-header">
      <div>
        <h3 data-i18n="settings.title">Session Settings</h3>
      </div>
      <button id="btnCloseSettings" class="icon-button" aria-label="Close settings" data-i18n-attr="aria-label:settings.close">&times;</button>
    </div>
    <div class="settings-body">
      <section class="form-card">
        <h4 data-i18n="settings.section.adventureTone">Adventure tone</h4>
        <div class="grid2">
          <label>
            <span data-i18n="settings.worldStyle.label">World style</span>
            <div class="world-style-picker">
              <button type="button" id="worldStyleToggle" class="world-style-trigger" aria-haspopup="listbox" aria-expanded="false">High Fantasy</button>
              <div id="worldStyleMenu" class="world-style-menu hidden" role="listbox" aria-labelledby="worldStyleToggle"></div>
              <input id="setWorld" type="hidden" value="" />
            </div>
            <input id="setWorldCustom" class="world-custom-input hidden" type="text" autocomplete="off" data-i18n-attr="placeholder:settings.worldStyle.customPlaceholder" placeholder="Describe your world style" disabled />
          </label>
          <label>
            <span data-i18n="settings.difficulty.label">Difficulty</span>
            <select id="setDiff">
              <option value="Trivial" data-i18n-option="settings.difficulty.option.trivial">Trivial</option>
              <option value="Easy" data-i18n-option="settings.difficulty.option.easy">Easy</option>
              <option value="Normal" selected data-i18n-option="settings.difficulty.option.normal">Normal</option>
              <option value="Hard" data-i18n-option="settings.difficulty.option.hard">Hard</option>
              <option value="Impossible" data-i18n-option="settings.difficulty.option.impossible">Impossible</option>
            </select>
          </label>
        </div>
      </section>
      <section class="form-card">
        <h4 data-i18n="settings.section.models">Models</h4>
        <div class="grid2">
          <label>
            <span data-i18n="settings.textModel.label">Text model</span>
            <select id="setTextModel"></select>
          </label>
          <label>
            <span data-i18n="settings.thinking.label">Thinking mode</span>
            <select id="setThinking">
              <option value="none" selected data-i18n-option="settings.thinking.option.none">No thinking (fast)</option>
              <option value="brief" data-i18n-option="settings.thinking.option.brief">Brief planning</option>
              <option value="balanced" data-i18n-option="settings.thinking.option.balanced">Balanced</option>
              <option value="deep" data-i18n-option="settings.thinking.option.deep">Deep reasoning</option>
            </select>
          </label>
          <label>
            <span data-i18n="settings.imageModel.label">Image model</span>
            <select id="setImageModel"></select>
          </label>
          <label>
            <span data-i18n="settings.videoModel.label">Video model</span>
            <select id="setVideoModel"></select>
          </label>
          <label>
            <span data-i18n="settings.videoLength.label">Video length</span>
            <div class="video-length-input">
              <input id="setVideoLength" type="number" min="1" max="120" step="1" />
              <span class="video-length-suffix" data-i18n="settings.videoLength.suffix">seconds</span>
            </div>
          </label>
          <label>
            <span data-i18n="settings.narrationModel.label">Narration model</span>
            <select id="setNarrationModel"></select>
          </label>
        </div>
      </section>
      <section class="form-card">
        <h4 data-i18n="settings.section.flow">Session flow &amp; performance</h4>
        <label>
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <span data-i18n="settings.historyMode.summaryLabel">Send summary instead of full history</span>
            <input id="setHistorySummary" type="checkbox" role="switch" data-i18n-attr="aria-label:settings.historyMode.summaryLabel" />
          </div>
          <span class="tip" data-i18n="settings.historyMode.summaryHint">When enabled, only a concise bullet summary is sent to the GM instead of full history.</span>
        </label>
        <label>
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <span data-i18n="settings.fxSaver.label">FX Saver (disable blur effects)</span>
            <input id="setFxSaver" type="checkbox" role="switch" data-i18n-attr="aria-label:settings.fxSaver.label" />
          </div>
          <span class="tip" data-i18n="settings.fxSaver.hint">Reduce GPU-heavy visual effects on lower power devices.</span>
        </label>
      </section>
      <section class="form-card">
        <h4 data-i18n="settings.section.access">Access</h4>
        <div class="grid2">
          <label>
            <span data-i18n="settings.geminiKey.label">Gemini API key</span>
            <input id="setKey" type="text" placeholder="Paste your key…" data-i18n-attr="placeholder:settings.apiKeyPlaceholder" />
          </label>
          <label>
            <span data-i18n="settings.grokKey.label">Grok API key</span>
            <input id="setGrokKey" type="text" placeholder="Paste your key…" data-i18n-attr="placeholder:settings.apiKeyPlaceholder" />
          </label>
          <label>
            <span data-i18n="settings.openaiKey.label">OpenAI API key</span>
            <input id="setOpenAIKey" type="text" placeholder="Paste your key…" data-i18n-attr="placeholder:settings.apiKeyPlaceholder" />
          </label>
          <label>
            <span data-i18n="settings.elevenKey.label">ElevenLabs API key</span>
            <input id="setElevenKey" type="text" placeholder="Paste your key…" data-i18n-attr="placeholder:settings.apiKeyPlaceholder" />
          </label>
        </div>
      </section>
    </div>
    <div class="settings-footer">
      <div class="share-chip">
        <span data-i18n="settings.share.label">Players join via</span>
        <code id="shareUrl"></code>
      </div>
      <button id="btnSaveSettings" class="primary" data-i18n="settings.save">Save changes</button>
    </div>
  </div>
</div>

<!-- Statistics modal -->
<div id="statsBack" class="modalBack">
  <div class="modal">
    <h3 data-i18n="stats.main.title">Usage overview</h3>
    <div class="stats-summary">
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.lastTurnCost">Last Turn Cost</span>
        <span id="statsCostLast" class="stat-chip-value">—</span>
      </div>
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.sessionCost">Session Cost</span>
        <span id="statsCostSession" class="stat-chip-value">—</span>
      </div>
    </div>
    <div class="stats-actions">
      <button id="btnStatsText" data-i18n="stats.main.textDetails">Text details</button>
      <button id="btnStatsImage" data-i18n="stats.main.imageDetails">Image details</button>
      <button id="btnStatsVideo" data-i18n="stats.main.videoDetails">Video details</button>
      <button id="btnStatsNarration" data-i18n="stats.main.narrationDetails">Narration details</button>
    </div>
    <div class="tip" data-i18n="stats.main.tip">Open a category to see token and cost breakdowns.</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseStats" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<div id="statsTextBack" class="modalBack">
  <div class="modal">
    <h3 data-i18n="stats.text.title">Text usage details</h3>
    <div class="stats-summary">
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.lastTurnCost">Last Turn Cost</span>
        <span id="statsTextCostLast" class="stat-chip-value">—</span>
      </div>
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.sessionCost">Session Cost</span>
        <span id="statsTextCostSession" class="stat-chip-value">—</span>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.text.lastTokens">Last Turn Tokens (in / out / thinking)</span>
        <span id="statsTextTokensLast" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.text.sessionTokens">Session Tokens (in / out / thinking)</span>
        <span id="statsTextTokensSession" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.text.lastTotal">Last Turn Total Tokens</span>
        <span id="statsTextTokensLastTotal" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.text.sessionTotal">Session Total Tokens</span>
        <span id="statsTextTokensSessionTotal" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.text.throughput">Throughput</span>
        <span id="statsTextRate" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.shared.sessionRequests">Session Requests</span>
        <span id="statsTextRequests" class="stat-value">—</span>
      </div>
    </div>
    <div class="tip" data-i18n="stats.text.tip">Token totals include thinking tokens when supported.</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseStatsText" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<div id="statsImageBack" class="modalBack">
  <div class="modal">
    <h3 data-i18n="stats.image.title">Image usage details</h3>
    <div class="stats-summary">
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.image.turnCost">This Turn Image Cost</span>
        <span id="statsImageCostLast" class="stat-chip-value">—</span>
      </div>
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.image.sessionCost">Session Image Cost</span>
        <span id="statsImageCostSession" class="stat-chip-value">—</span>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.image.lastModel">Last Image Model</span>
        <span id="statsImageModel" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.image.sessionCount">Session Images Generated</span>
        <span id="statsImageCountSession" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.image.avgCost">Average Cost Per Image</span>
        <span id="statsImageAvgCost" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.image.turnByType">This Turn Images by Type</span>
        <span id="statsImageTurnCounts" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.image.sessionByType">Session Images by Type</span>
        <span id="statsImageSessionCounts" class="stat-value">—</span>
      </div>
    </div>
    <div class="tip" data-i18n="stats.image.tip">Image pricing uses Gemini per-image rates (standard tier).</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseStatsImage" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<div id="statsVideoBack" class="modalBack">
  <div class="modal">
    <h3 data-i18n="stats.video.title">Video usage details</h3>
    <div class="stats-summary">
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.video.turnCost">This Turn Video Cost</span>
        <span id="statsVideoCostLast" class="stat-chip-value">—</span>
      </div>
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.video.sessionCost">Session Video Cost</span>
        <span id="statsVideoCostSession" class="stat-chip-value">—</span>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.lastModel">Last Video Model</span>
        <span id="statsVideoModel" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.lastSeconds">Last Video Duration (seconds)</span>
        <span id="statsVideoSecondsLast" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.sessionSeconds">Session Video Duration</span>
        <span id="statsVideoSecondsSession" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.usdPerSecond">USD per second</span>
        <span id="statsVideoUsdPerSecond" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.avgUsdPerSecond">Average USD per second</span>
        <span id="statsVideoAvgUsdPerSecond" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.requests">Session Requests</span>
        <span id="statsVideoRequests" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.video.avgSecondsPerRequest">Average seconds per request</span>
        <span id="statsVideoAvgSecondsPerRequest" class="stat-value">—</span>
      </div>
    </div>
    <div class="tip" data-i18n="stats.video.tip">Video pricing uses Veo per-second rates for generated clips.</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseStatsVideo" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<div id="statsNarrationBack" class="modalBack">
  <div class="modal">
    <h3 data-i18n="stats.narration.title">Narration usage details</h3>
    <div class="stats-summary">
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.lastTurnCost">Last Turn Cost</span>
        <span id="statsNarrationCostLast" class="stat-chip-value">—</span>
      </div>
      <div class="stat-chip">
        <span class="stat-chip-label" data-i18n="stats.shared.sessionCost">Session Cost</span>
        <span id="statsNarrationCostSession" class="stat-chip-value">—</span>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.lastChars">Last Turn Characters</span>
        <span id="statsNarrationCharsLast" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.lastCredits">Last Turn Credits</span>
        <span id="statsNarrationCreditsLast" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.lastModel">Last Narration Model</span>
        <span id="statsNarrationModel" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.sessionChars">Session Characters</span>
        <span id="statsNarrationCharsSession" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.sessionCredits">Session Credits</span>
        <span id="statsNarrationCreditsSession" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.voiceId">Voice ID</span>
        <span id="statsNarrationVoice" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.shared.sessionRequests">Session Requests</span>
        <span id="statsNarrationRequests" class="stat-value">—</span>
      </div>
      <div class="stat-card">
        <span class="stat-label" data-i18n="stats.narration.remainingCredits">Remaining Credits</span>
        <span id="statsNarrationCreditsRemaining" class="stat-value">—</span>
      </div>
    </div>
    <div class="tip" data-i18n="stats.narration.tip">Cost estimates use ElevenLabs response headers when available; otherwise we fall back to text length and official pricing.</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseStatsNarration" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<div id="devInfoBack" class="modalBack">
  <div class="modal dev-info-modal">
    <h3 data-i18n="devInfo.title">Text API exchange</h3>
    <div class="dev-info-grid">
      <section class="dev-info-section">
        <h4 data-i18n="devInfo.request">Last request</h4>
        <pre id="devInfoRequest" class="dev-info-pre"></pre>
      </section>
      <section class="dev-info-section">
        <h4 data-i18n="devInfo.response">Last response</h4>
        <pre id="devInfoResponse" class="dev-info-pre"></pre>
      </section>
    </div>
    <div class="tip" data-i18n="devInfo.tip">Shows the most recent payload sent to the text model and the raw response it returned.</div>
    <div class="row" style="margin-top:12px">
        <button id="btnCloseDevInfo" class="right" data-i18n="stats.shared.close">Close</button>
    </div>
  </div>
</div>

<script>
  const FX_STORAGE_KEY = 'orpg-nofx';

  function readFxPreference() {
    try {
      if (window.localStorage) {
        const value = localStorage.getItem(FX_STORAGE_KEY);
        if (value === '0') return false;
        if (value === '1') return true;
      }
    } catch (err) {
      /* ignore storage errors */
    }
    return true;
  }

  function persistFxPreference(enabled) {
    try {
      if (!window.localStorage) return;
      localStorage.setItem(FX_STORAGE_KEY, enabled ? '1' : '0');
    } catch (err) {
      /* ignore storage errors */
    }
  }

  const fxParam = new URLSearchParams(window.location.search).get('fx');
  let initialFxSaver = readFxPreference();
  if (fxParam === '0') {
    initialFxSaver = true;
    persistFxPreference(true);
  } else if (fxParam === '1') {
    initialFxSaver = false;
    persistFxPreference(false);
  }
  if (initialFxSaver) {
    document.documentElement.classList.add('nofx');
  }

  const $ = (id) => document.getElementById(id);

  const JOIN_BACKGROUND_FALLBACKS = [
    "/static/img/ashen-citadel.png",
    "/static/img/crescent-gateway.png",
    "/static/img/dungeon-gate.png",
    "/static/img/emberspire-citadel.png",
    "/static/img/forgotten-crypt.png",
    "/static/img/gloom-hall.png",
    "/static/img/omen-sorcerer.png",
    "/static/img/verdant-gateway.png",
  ];

  const joinBackgroundState = {
    items: [],
    fetchPromise: null,
    hydrated: false,
  };

  function getJoinBackgroundPool() {
    return joinBackgroundState.items.length ? joinBackgroundState.items : JOIN_BACKGROUND_FALLBACKS;
  }

  function loadJoinBackgrounds() {
    if (joinBackgroundState.fetchPromise) return joinBackgroundState.fetchPromise;
    const request = fetch('/api/join_backgrounds', { cache: 'no-store' })
      .then((resp) => (resp && resp.ok ? resp.json() : { backgrounds: [] }))
      .then((payload) => {
        const backgrounds = payload && Array.isArray(payload.backgrounds) ? payload.backgrounds : [];
        const sanitized = backgrounds
          .map((entry) => (typeof entry === 'string' ? entry.trim() : ''))
          .filter((entry) => entry.length > 0);
        joinBackgroundState.items = sanitized;
        const hasBackgrounds = sanitized.length > 0;
        const shouldForce = hasBackgrounds && !joinBackgroundState.hydrated;
        if (hasBackgrounds) {
          joinBackgroundState.hydrated = true;
        } else {
          joinBackgroundState.hydrated = false;
        }
        ensureJoinBackgroundFromPool({ force: shouldForce });
        return getJoinBackgroundPool();
      })
      .catch(() => getJoinBackgroundPool())
      .finally(() => {
        joinBackgroundState.fetchPromise = null;
      });
    joinBackgroundState.fetchPromise = request;
    return request;
  }

  function pickJoinBackground() {
    const pool = getJoinBackgroundPool();
    if (!pool.length) return null;
    const index = Math.floor(Math.random() * pool.length);
    return pool[index];
  }

  function shuffleList(items) {
    const next = items.slice();
    for (let i = next.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      const tmp = next[i];
      next[i] = next[j];
      next[j] = tmp;
    }
    return next;
  }

  const joinMusicState = {
    library: [],
    queue: [],
    audio: null,
    unlockHandler: null,
    fetchPromise: null,
    fadeHandle: null,
  };

  const JOIN_MUSIC_DEFAULT_VOLUME = 0.55;
  const JOIN_MUSIC_FADE_DURATION_MS = 3000;
  const JOIN_MUSIC_MIN_VOLUME = 0.001;

  function timeNow() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      return performance.now();
    }
    return Date.now();
  }

  function requestJoinMusicFrame(callback) {
    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
      const id = window.requestAnimationFrame(callback);
      return {
        type: 'raf',
        id,
        cancel() {
          if (typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function') {
            window.cancelAnimationFrame(id);
          }
        },
      };
    }
    const timeout = setTimeout(() => {
      callback(timeNow());
    }, 16);
    return {
      type: 'timeout',
      id: timeout,
      cancel() {
        clearTimeout(timeout);
      },
    };
  }

  function cancelJoinMusicFrame(handle) {
    if (!handle) return;
    try {
      if (typeof handle.cancel === 'function') {
        handle.cancel();
        return;
      }
      if (handle.type === 'raf' && typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function') {
        window.cancelAnimationFrame(handle.id);
      } else if (handle.type === 'timeout') {
        clearTimeout(handle.id);
      }
    } catch (err) {
      /* ignore cancellation errors */
    }
  }

  function clearJoinMusicFade(options = {}) {
    if (joinMusicState.fadeHandle) {
      cancelJoinMusicFrame(joinMusicState.fadeHandle);
      joinMusicState.fadeHandle = null;
    }
    if (options.restoreVolume) {
      const current = joinMusicState.audio;
      if (current) {
        try {
          current.volume = JOIN_MUSIC_DEFAULT_VOLUME;
        } catch (err) {
          /* ignore audio volume errors */
        }
      }
    }
  }

  function joinScreenIsActive() {
    return Boolean(document && document.body && document.body.classList.contains('join-screen'));
  }

  function clearJoinMusicUnlock() {
    if (!joinMusicState.unlockHandler) return;
    window.removeEventListener('pointerdown', joinMusicState.unlockHandler);
    window.removeEventListener('keydown', joinMusicState.unlockHandler);
    joinMusicState.unlockHandler = null;
  }

  function stopJoinMusic(options = {}) {
    const audio = joinMusicState.audio;
    const resetPosition = options.resetPosition !== false;
    if (options.resetQueue) {
      joinMusicState.queue = [];
    }
    clearJoinMusicUnlock();
    if (!audio) {
      clearJoinMusicFade();
      return;
    }

    const fadeDuration =
      typeof options.fadeDurationMs === 'number' && options.fadeDurationMs > 0
        ? options.fadeDurationMs
        : 0;

    if (fadeDuration > 0 && !audio.paused && audio.volume > JOIN_MUSIC_MIN_VOLUME) {
      const startVolume = audio.volume;
      const startTime = timeNow();
      clearJoinMusicFade();

      const finish = () => {
        if (joinMusicState.audio === audio) {
          joinMusicState.audio = null;
        }
        try {
          audio.volume = 0;
        } catch (err) {
          /* ignore volume errors */
        }
        audio.pause();
        if (resetPosition) {
          try {
            audio.currentTime = 0;
          } catch (err) {
            /* ignore currentTime errors */
          }
        }
        try {
          audio.volume = JOIN_MUSIC_DEFAULT_VOLUME;
        } catch (err) {
          /* ignore volume reset errors */
        }
      };

      const step = (timestamp) => {
        if (joinMusicState.audio !== audio) {
          joinMusicState.fadeHandle = null;
          return;
        }
        const now = typeof timestamp === 'number' ? timestamp : timeNow();
        const elapsed = Math.max(0, now - startTime);
        const progress = Math.min(1, fadeDuration > 0 ? elapsed / fadeDuration : 1);
        const remaining = Math.max(0, 1 - progress);
        const nextVolume = remaining <= 0 ? 0 : startVolume * remaining;
        try {
          audio.volume = nextVolume <= JOIN_MUSIC_MIN_VOLUME ? 0 : nextVolume;
        } catch (err) {
          /* ignore volume errors */
        }
        if (progress < 1 && !audio.paused && audio.volume > 0) {
          joinMusicState.fadeHandle = requestJoinMusicFrame(step);
          return;
        }
        joinMusicState.fadeHandle = null;
        finish();
      };

      joinMusicState.fadeHandle = requestJoinMusicFrame(step);
      return;
    }

    clearJoinMusicFade();
    try {
      audio.volume = 0;
    } catch (err) {
      /* ignore volume errors */
    }
    audio.pause();
    if (resetPosition) {
      try {
        audio.currentTime = 0;
      } catch (err) {
        /* ignore currentTime errors */
      }
    }
    try {
      audio.volume = JOIN_MUSIC_DEFAULT_VOLUME;
    } catch (err) {
      /* ignore volume reset errors */
    }
    if (joinMusicState.audio === audio) {
      joinMusicState.audio = null;
    }
  }

  function joinMusicAvailable() {
    return Array.isArray(joinMusicState.library) && joinMusicState.library.length > 0;
  }

  function resetJoinMusicQueue() {
    if (!joinMusicAvailable()) {
      joinMusicState.queue = [];
      return;
    }
    joinMusicState.queue = shuffleList(joinMusicState.library);
  }

  function nextJoinTrack() {
    if (!joinMusicAvailable()) return null;
    if (!joinMusicState.queue.length) {
      resetJoinMusicQueue();
    }
    return joinMusicState.queue.shift() || null;
  }

  function playNextJoinSong() {
    if (!joinScreenIsActive()) return;
    const track = nextJoinTrack();
    if (!track) return;
    clearJoinMusicFade();
    const audio = new Audio(track.src);
    audio.preload = 'auto';
    audio.loop = false;
    audio.volume = JOIN_MUSIC_DEFAULT_VOLUME;
    joinMusicState.audio = audio;
    const handleNext = () => {
      if (joinMusicState.audio === audio) {
        joinMusicState.audio = null;
        playNextJoinSong();
      }
    };
    audio.addEventListener('ended', handleNext);
    audio.addEventListener('error', handleNext);
    const attempt = audio.play();
    if (attempt && typeof attempt.then === 'function') {
      attempt.then(() => {
        clearJoinMusicUnlock();
      }).catch(() => {
        // Autoplay likely blocked; wait for user interaction.
      });
    } else {
      clearJoinMusicUnlock();
    }
  }

  function attemptJoinMusicPlayback() {
    if (!joinScreenIsActive() || !joinMusicAvailable()) return;
    const current = joinMusicState.audio;
    if (current) {
      if (!current.paused) return;
      const attempt = current.play();
      if (attempt && typeof attempt.then === 'function') {
        attempt.then(() => {
          clearJoinMusicUnlock();
        }).catch(() => {
          // Autoplay still blocked; keep unlock handler.
        });
      }
      return;
    }
    playNextJoinSong();
  }

  function setJoinMusicLibrary(rawSongs) {
    const normalized = [];
    if (Array.isArray(rawSongs)) {
      rawSongs.forEach((song, index) => {
        if (!song || typeof song !== 'object') return;
        const src = typeof song.src === 'string' ? song.src.trim() : '';
        if (!src) return;
        const id = typeof song.id === 'string' && song.id.trim() ? song.id.trim() : `song_${index}`;
        const title = typeof song.title === 'string' && song.title.trim() ? song.title.trim() : id;
        normalized.push({ id, src, title });
      });
    }
    joinMusicState.library = normalized;
    joinMusicState.queue = [];
    if (!normalized.length) {
      stopJoinMusic({ resetQueue: true });
    }
  }

  function loadJoinMusicLibrary() {
    if (joinMusicState.fetchPromise) return joinMusicState.fetchPromise;
    const request = fetch('/api/join_songs', { cache: 'no-store' })
      .then((resp) => (resp && resp.ok ? resp.json() : { songs: [] }))
      .then((payload) => {
        const songs = payload && Array.isArray(payload.songs) ? payload.songs : [];
        setJoinMusicLibrary(songs);
        if (joinScreenIsActive()) {
          attemptJoinMusicPlayback();
        }
        return joinMusicState.library;
      })
      .catch(() => {
        setJoinMusicLibrary([]);
        return joinMusicState.library;
      })
      .finally(() => {
        joinMusicState.fetchPromise = null;
      });
    joinMusicState.fetchPromise = request;
    return request;
  }

  function armJoinMusicUnlock() {
    if (joinMusicState.unlockHandler) return;
    loadJoinMusicLibrary();
    const handler = () => {
      ensureJoinMusic();
      const current = joinMusicState.audio;
      if (current && !current.paused) {
        clearJoinMusicUnlock();
      }
    };
    joinMusicState.unlockHandler = handler;
    window.addEventListener('pointerdown', handler, { passive: true });
    window.addEventListener('keydown', handler, { passive: true });
  }

  function ensureJoinMusic() {
    if (joinMusicAvailable()) {
      clearJoinMusicFade({ restoreVolume: true });
      attemptJoinMusicPlayback();
      return;
    }
    loadJoinMusicLibrary().then(() => {
      clearJoinMusicFade({ restoreVolume: true });
      attemptJoinMusicPlayback();
    }).catch(() => {
      /* ignore fetch errors */
    });
  }

  function applyJoinBackground(url) {
    if (!document || !document.body) return;
    if (url) {
      document.body.style.setProperty('--join-screen-bg', `url("${url}")`);
    } else {
      document.body.style.removeProperty('--join-screen-bg');
    }
  }

  const DEFAULT_VIDEO_LENGTH_SECONDS = 8;
  const VIDEO_LENGTH_MIN_SECONDS = 1;
  const VIDEO_LENGTH_MAX_SECONDS = 120;

  const state = {
    playerId: null,
    playerToken: null,
    playerName: '',
    playerBackground: '',
    pendingJoin: null,
    lock: {active:false, reason:""},
    lastPublic: null,
    autoTtsEnabled: false,
    autoImageEnabled: false,
    autoVideoEnabled: false,
    language: 'en',
    joinBackgroundUrl: null,
    currentTurn: 0,
    joinStatusKey: null,
    joinStatusArgs: null,
    lastPrivate: null,
    sceneVideoUrl: null,
    sceneVideoToken: null,
    sceneVideoUserPaused: false,
    fxSaverEnabled: initialFxSaver,
    videoLengthSeconds: DEFAULT_VIDEO_LENGTH_SECONDS,
    youHighlights: {
      turn: 0,
      abilities: new Map(),
      inventory: new Map(),
      conditions: new Map(),
    },
    youRemovals: {
      turn: 0,
      abilities: new Map(),
      inventory: new Map(),
      conditions: new Map(),
    },
  };

  let ignoreSceneVideoPause = false;

  function ensureJoinBackgroundFromPool(options = {}) {
    const pool = getJoinBackgroundPool();
    if (!pool.length) return;
    const force = options && options.force === true;
    if (force || !state.joinBackgroundUrl || !pool.includes(state.joinBackgroundUrl)) {
      state.joinBackgroundUrl = pickJoinBackground();
      applyJoinBackground(state.joinBackgroundUrl);
    }
  }

  function applyFxSaver(enabled, options = {}) {
    if (enabled) {
      document.documentElement.classList.add('nofx');
    } else {
      document.documentElement.classList.remove('nofx');
    }
    state.fxSaverEnabled = !!enabled;
    if (options.persist) {
      persistFxPreference(state.fxSaverEnabled);
    }
  }

  let lastLanguageSync = null;

  const narrationState = {
    current: null,
  };

  const narrativeScrollState = {
    lastTurnScrolled: null,
  };

  let narrativeSizer;

  const LEAVE_NOTICE_GRACE_MS = 5000;
  const leaveNoticeState = new Map();

  function normalizeId(value) {
    if (value == null) return null;
    if (typeof value === 'string') return value;
    try {
      const text = String(value);
      return text || null;
    } catch (err) {
      return null;
    }
  }

  function clearLeaveNotice(pid) {
    if (!pid) return;
    const entry = leaveNoticeState.get(pid);
    if (entry && entry.timer) {
      clearTimeout(entry.timer);
    }
    leaveNoticeState.delete(pid);
  }

  function triggerLeaveNoticeUpdate(pid) {
    if (state.lastPublic) {
      renderPublic(state.lastPublic);
    }
    const you = state.lastPrivate && state.lastPrivate.you ? state.lastPrivate.you : null;
    const youId = you ? normalizeId(you.id) : null;
    if (youId && youId === pid) {
      renderPrivate(state.lastPrivate);
    }
  }

  function shouldShowLeaveNotice(pid, pendingLeave) {
    if (!pendingLeave) {
      if (pid) {
        clearLeaveNotice(pid);
      }
      return false;
    }
    if (!pid) {
      return true;
    }
    const now = Date.now();
    let entry = leaveNoticeState.get(pid);
    if (!entry) {
      entry = { started: now, ready: false, timer: null };
      leaveNoticeState.set(pid, entry);
    }
    if (entry.ready) {
      return true;
    }
    const elapsed = now - entry.started;
    if (elapsed >= LEAVE_NOTICE_GRACE_MS) {
      entry.ready = true;
      if (entry.timer) {
        clearTimeout(entry.timer);
        entry.timer = null;
      }
      leaveNoticeState.set(pid, entry);
      return true;
    }
    if (!entry.timer) {
      const delay = Math.max(LEAVE_NOTICE_GRACE_MS - elapsed, 0);
      entry.timer = setTimeout(() => {
        const stored = leaveNoticeState.get(pid);
        if (!stored) return;
        stored.ready = true;
        stored.timer = null;
        leaveNoticeState.set(pid, stored);
        triggerLeaveNoticeUpdate(pid);
      }, delay);
      leaveNoticeState.set(pid, entry);
    }
    return false;
  }

  function pruneLeaveNoticeState(activeIds) {
    leaveNoticeState.forEach((entry, pid) => {
      if (!activeIds.has(pid)) {
        if (entry && entry.timer) {
          clearTimeout(entry.timer);
        }
        leaveNoticeState.delete(pid);
      }
    });
  }

  const joinDragState = {
    initialized: false,
    dragging: false,
    dragged: false,
    offsetX: 0,
    offsetY: 0,
    width: 0,
    height: 0,
    detachMouse: null,
    detachTouch: null,
  };

  const MODAL_IDS = [
    "settingsBack",
    "statsBack",
    "statsTextBack",
    "statsImageBack",
    "statsVideoBack",
    "statsNarrationBack",
    "devInfoBack",
  ];

  const modalStack = [];

  function showModal(id) {
    const el = $(id);
    if (!el) return false;
    const existingIndex = modalStack.indexOf(id);
    if (existingIndex >= 0) {
      modalStack.splice(existingIndex, 1);
    }
    modalStack.push(id);
    el.style.display = 'flex';
    syncJoinViewModalVisibility();
    return true;
  }

  function hideModal(id) {
    const el = $(id);
    if (!el) return false;
    el.style.display = 'none';
    const existingIndex = modalStack.indexOf(id);
    if (existingIndex >= 0) {
      modalStack.splice(existingIndex, 1);
    }
    syncJoinViewModalVisibility();
    return true;
  }

  function getTopModalId() {
    for (let i = modalStack.length - 1; i >= 0; i -= 1) {
      const id = modalStack[i];
      const el = $(id);
      if (isModalVisible(el)) {
        return id;
      }
      modalStack.splice(i, 1);
    }
    for (let i = MODAL_IDS.length - 1; i >= 0; i -= 1) {
      const id = MODAL_IDS[i];
      if (isModalVisible($(id))) {
        return id;
      }
    }
    return null;
  }

  const HIDDEN_JOIN_STATUS_KEYS = new Set([
    'join.status.requestSent',
    'join.status.creatingWorld',
    'join.status.queueAfterTurn',
    'join.status.queueActive',
    'join.status.preparing',
    'join.status.waitingQueued',
    'join.status.waitingActive',
    'join.status.waitingIdle',
  ]);

  function isModalVisible(element) {
    if (!element) return false;
    const directDisplay = element.style.display;
    if (directDisplay) {
      return directDisplay !== "none";
    }
    return window.getComputedStyle(element).display !== "none";
  }

  function closeOpenModals() {
    const topId = getTopModalId();
    if (!topId) return false;
    hideModal(topId);
    return true;
  }

  const joinModalHideState = {
    active: false,
    previousDisplay: '',
  };

  function anyModalVisible() {
    for (const id of MODAL_IDS) {
      if (isModalVisible($(id))) {
        return true;
      }
    }
    return false;
  }

  function syncJoinViewModalVisibility() {
    const joinView = $("joinView");
    if (!joinView) return;
    const joinScreenActive = Boolean(document && document.body && document.body.classList.contains('join-screen'));
    const modalVisible = joinScreenActive && anyModalVisible();
    if (modalVisible) {
      if (!joinModalHideState.active) {
        joinModalHideState.active = true;
        joinModalHideState.previousDisplay = joinView.style.display || '';
        joinView.style.display = 'none';
      }
    } else if (joinModalHideState.active) {
      joinModalHideState.active = false;
      const previousDisplay = joinModalHideState.previousDisplay;
      joinModalHideState.previousDisplay = '';
      if (joinScreenActive) {
        joinView.style.display = previousDisplay || '';
      }
    }
  }

  const DEFAULT_LANGUAGE = 'en';
  const SUPPORTED_LANGUAGES = ['en', 'de'];
  const LANGUAGE_STORAGE_KEY = 'orpg-language';
  let DEFAULT_WORLD_STYLE = 'High Fantasy';
  const DEFAULT_TEXT_MODEL = 'grok-4-fast-non-reasoning';
  const DEFAULT_VIDEO_MODEL = 'veo-3.0-generate-001';
  const CUSTOM_WORLD_VALUE = '__custom__';
  const WORLD_STYLE_SOURCE_PATH = '/static/world-styles.json';
  const WORLD_STYLE_APPLIES_HINTS = {
    any: 'Layer on any world',
  };
  const WORLD_STYLE_CUSTOM_ENTRY = {
    name: 'Custom…',
    value: CUSTOM_WORLD_VALUE,
    appliesTo: null,
    depth: 0,
    children: [],
  };
  function normalizeWorldStyleValue(value) {
    if (typeof value !== 'string') return '';
    return value.trim().toLowerCase();
  }

  function normalizeWorldStyleNode(node) {
    if (node == null) return null;
    if (typeof node === 'string') {
      const trimmed = node.trim();
      return trimmed ? { name: trimmed, applies_to: null, children: [] } : null;
    }
    if (typeof node !== 'object') return null;
    const name = typeof node.name === 'string' ? node.name.trim() : '';
    if (!name) return null;
    const children = Array.isArray(node.children) ? node.children : [];
    const appliesTo = typeof node.applies_to === 'string' ? node.applies_to.trim() : null;
    return { name, children, applies_to: appliesTo };
  }
  const WORLD_STYLE_LOOKUP = new Map();

  function clampVideoLength(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
      return DEFAULT_VIDEO_LENGTH_SECONDS;
    }
    if (numeric < VIDEO_LENGTH_MIN_SECONDS) return VIDEO_LENGTH_MIN_SECONDS;
    if (numeric > VIDEO_LENGTH_MAX_SECONDS) return VIDEO_LENGTH_MAX_SECONDS;
    return Math.round(numeric);
  }

  function setVideoLengthValue(value, options = {}) {
    const input = $('setVideoLength');
    const clamped = clampVideoLength(value);
    const stringValue = String(clamped);
    if (input && input.value !== stringValue) {
      input.value = stringValue;
    }
    if (!options.silent) {
      state.videoLengthSeconds = clamped;
    }
    return clamped;
  }

  function updateVideoLengthDisabledState(modelValue) {
    const input = $('setVideoLength');
    const isVeo = typeof modelValue === 'string' && modelValue.trim().toLowerCase().startsWith('veo');
    if (input) {
      input.disabled = isVeo;
      if (isVeo) {
        input.setAttribute('title', t('settings.videoLength.disabledTitle'));
      } else {
        input.removeAttribute('title');
        input.setAttribute('title', t('settings.videoLength.tooltip'));
      }
    }
  }

  function bindVideoLengthControls() {
    const input = $('setVideoLength');
    if (input) {
      input.addEventListener('input', () => {
        setVideoLengthValue(input.value);
      });
      input.addEventListener('blur', () => {
        setVideoLengthValue(input.value);
      });
    }
    setVideoLengthValue(state.videoLengthSeconds ?? DEFAULT_VIDEO_LENGTH_SECONDS, { silent: true });
  }
  const WORLD_STYLE_PARENT_MAP = new Map();
  let WORLD_STYLE_ENTRIES = [];
  const WORLD_STYLE_FALLBACK_TREE = [
    {
      name: 'Fantasy',
      children: [
        { name: 'High Fantasy' },
      ],
    },
  ];
  function buildWorldStyleEntries(nodes, depth = 0, parentKey = null) {
    if (!Array.isArray(nodes)) return [];
    return nodes
      .map((node) => {
        const normalizedNode = normalizeWorldStyleNode(node);
        if (!normalizedNode) return null;
        const entry = {
          name: normalizedNode.name,
          value: normalizedNode.name,
          appliesTo: normalizedNode.applies_to,
          depth,
          children: [],
        };
        const key = normalizeWorldStyleValue(entry.value);
        if (key && !WORLD_STYLE_LOOKUP.has(key)) {
          WORLD_STYLE_LOOKUP.set(key, entry);
        }
        if (key && parentKey) {
          WORLD_STYLE_PARENT_MAP.set(key, parentKey);
        }
        if (Array.isArray(normalizedNode.children) && normalizedNode.children.length) {
          entry.children = buildWorldStyleEntries(normalizedNode.children, depth + 1, key);
        }
        return entry;
      })
      .filter((entry) => entry && entry.value);
  }
  function findFirstLeafValue(entries) {
    if (!Array.isArray(entries)) return null;
    for (const entry of entries) {
      if (!entry) continue;
      if (Array.isArray(entry.children) && entry.children.length) {
        const child = findFirstLeafValue(entry.children);
        if (child) return child;
      }
      if (entry.value) return entry.value;
    }
    return null;
  }
  function applyWorldStyleTree(tree) {
    WORLD_STYLE_LOOKUP.clear();
    WORLD_STYLE_PARENT_MAP.clear();
    WORLD_STYLE_ENTRIES = buildWorldStyleEntries(tree);
    WORLD_STYLE_LOOKUP.set(normalizeWorldStyleValue(WORLD_STYLE_CUSTOM_ENTRY.value), WORLD_STYLE_CUSTOM_ENTRY);
    if (!findWorldStyleEntry(DEFAULT_WORLD_STYLE)) {
      const firstLeaf = findFirstLeafValue(WORLD_STYLE_ENTRIES);
      if (firstLeaf) {
        DEFAULT_WORLD_STYLE = firstLeaf;
      }
    }
  }
  async function loadWorldStyleData() {
    try {
      const resp = await fetch(WORLD_STYLE_SOURCE_PATH, { cache: 'no-cache' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const payload = await resp.json();
      const tree = Array.isArray(payload?.world_styles) ? payload.world_styles : Array.isArray(payload) ? payload : null;
      if (!Array.isArray(tree) || !tree.length) throw new Error('Invalid world style payload');
      applyWorldStyleTree(tree);
    } catch (err) {
      console.warn('Failed to load world styles; using fallback', err);
      applyWorldStyleTree(WORLD_STYLE_FALLBACK_TREE);
    }
  }
  let worldStyleLoadPromise = null;
  function ensureWorldStylesInitialized() {
    if (WORLD_STYLE_ENTRIES.length) {
      return Promise.resolve();
    }
    if (!worldStyleLoadPromise) {
      worldStyleLoadPromise = loadWorldStyleData();
    }
    return worldStyleLoadPromise;
  }
  function findWorldStyleEntry(value) {
    const key = normalizeWorldStyleValue(value);
    return key ? WORLD_STYLE_LOOKUP.get(key) : undefined;
  }
  function worldStyleExists(value) {
    if (normalizeWorldStyleValue(value) === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) return true;
    return !!findWorldStyleEntry(value);
  }
  let worldStyleMenuInitialized = false;
  const JOIN_DEFAULTS = {
    en: { name: "Hephaest", background: "Wizard" },
    de: { name: "Hephaest", background: "Zauberer" },
  };
  const KNOWN_JOIN_NAMES = new Set(Object.values(JOIN_DEFAULTS).map((entry) => entry.name));
  const KNOWN_JOIN_BACKGROUNDS = new Set(Object.values(JOIN_DEFAULTS).map((entry) => entry.background));
  const LANGUAGE_CODE_ALIASES = {
    en: 'en',
    eng: 'en',
    english: 'en',
    'american english': 'en',
    'british english': 'en',
    'us english': 'en',
    'uk english': 'en',
    'en-us': 'en',
    'en-gb': 'en',
    'en-au': 'en',
    'en-ca': 'en',
    'en-in': 'en',
    'global english': 'en',
    'general english': 'en',
    de: 'de',
    ger: 'de',
    deu: 'de',
    german: 'de',
    deutsch: 'de',
    'standard german': 'de',
    'german standard': 'de',
    'german (standard)': 'de',
    'de-de': 'de',
    'de-at': 'de',
    'de-ch': 'de',
  };
  function normalizeLanguageCodeToken(value) {
    if (value == null) return null;
    let text = String(value).trim().toLowerCase();
    if (!text) return null;
    ['(', '/', '|'].forEach((sep) => {
      if (text.includes(sep)) text = text.split(sep, 1)[0].trim();
    });
    text = text.replace(/_/g, '-');
    const guesses = new Set();
    guesses.add(text);
    if (text.includes('-')) {
      const head = text.split('-', 1)[0].trim();
      if (head) guesses.add(head);
      guesses.add(text.replace(/-/g, ''));
    }
    const spaced = text.replace(/-/g, ' ');
    if (spaced) guesses.add(spaced);
    for (const guess of guesses) {
      if (!guess) continue;
      const mapped = LANGUAGE_CODE_ALIASES[guess];
      if (mapped) return mapped;
      if (SUPPORTED_LANGUAGES.includes(guess)) return guess;
    }
    return null;
  }

  function modelSupportsLanguage(model, langCode) {
    const normalizedLang = normalizeLanguageCodeToken(langCode);
    if (!normalizedLang || normalizedLang === DEFAULT_LANGUAGE) return true;
    const languageCodes = Array.isArray(model?.language_codes) ? model.language_codes : [];
    for (const code of languageCodes) {
      if (normalizeLanguageCodeToken(code) === normalizedLang) return true;
    }
    const rawLanguages = Array.isArray(model?.languages) ? model.languages : [];
    for (const entry of rawLanguages) {
      if (normalizeLanguageCodeToken(entry) === normalizedLang) return true;
    }
    return false;
  }
  const TRANSLATIONS = {
    "alerts.createImageFailed": { en: "Create Image failed", de: "Bildgenerierung fehlgeschlagen" },
    "alerts.createImageFailedDetail": { en: "Create Image failed: {{message}}", de: "Bildgenerierung fehlgeschlagen: {{message}}" },
    "alerts.joinControl": { en: "Join the session to control narration.", de: "Tritt der Sitzung bei, um die Erzählung zu steuern." },
    "alerts.joinControlImage": { en: "Join the session to control scene images.", de: "Tritt der Sitzung bei, um Szenenbilder zu steuern." },
    "alerts.joinFailed": { en: "Join failed", de: "Beitritt fehlgeschlagen" },
    "alerts.joinFailedDetail": { en: "Join failed: {{message}}", de: "Beitritt fehlgeschlagen: {{message}}" },
    "alerts.modelsFetchFailed": { en: "Failed to fetch models. Ensure your Gemini, OpenAI, or Grok and ElevenLabs API keys are saved in Settings.", de: "Modelle konnten nicht geladen werden. Stelle sicher, dass deine Gemini-, OpenAI- oder Grok- sowie ElevenLabs-API-Schlüssel in den Einstellungen gespeichert sind." },
    "alerts.nextTurnFailed": { en: "Next turn failed", de: "Nächste Runde fehlgeschlagen" },
    "alerts.nextTurnFailedDetail": { en: "Next turn failed: {{message}}", de: "Nächste Runde fehlgeschlagen: {{message}}" },
    "alerts.portraitFailed": { en: "Portrait request failed", de: "Porträtanfrage fehlgeschlagen" },
    "alerts.portraitFailedDetail": { en: "Portrait request failed: {{message}}", de: "Porträtanfrage fehlgeschlagen: {{message}}" },
    "alerts.settingsSaveFailed": { en: "Failed to save settings.", de: "Einstellungen konnten nicht gespeichert werden." },
    "alerts.submitFailed": { en: "Submit failed", de: "Übermittlung fehlgeschlagen" },
    "alerts.submitFailedDetail": { en: "Submit failed: {{message}}", de: "Übermittlung fehlgeschlagen: {{message}}" },
    "alerts.toggleNarrationFailed": { en: "Toggle narration failed", de: "Erzählung umschalten fehlgeschlagen" },
    "alerts.toggleNarrationFailedDetail": { en: "Toggle narration failed: {{message}}", de: "Erzählung umschalten fehlgeschlagen: {{message}}" },
    "alerts.toggleImageFailed": { en: "Toggle scene images failed", de: "Automatisches Szenenbild umschalten fehlgeschlagen" },
    "alerts.toggleImageFailedDetail": { en: "Toggle scene images failed: {{message}}", de: "Automatisches Szenenbild umschalten fehlgeschlagen: {{message}}" },
    "alerts.toggleVideoFailed": { en: "Toggle scene animation failed", de: "Automatische Szenenanimation umschalten fehlgeschlagen" },
    "alerts.toggleVideoFailedDetail": { en: "Toggle scene animation failed: {{message}}", de: "Automatische Szenenanimation umschalten fehlgeschlagen: {{message}}" },
    "alerts.animateFailed": { en: "Animate scene failed", de: "Videoanimation fehlgeschlagen" },
    "alerts.animateFailedDetail": { en: "Animate scene failed: {{message}}", de: "Videoanimation fehlgeschlagen: {{message}}" },
    "common.working": { en: "Working…", de: "Verarbeite …" },
    "common.workingCountdown": { en: "Working… {{seconds}}s", de: "Verarbeite … {{seconds}}s" },
    "game.ability.unnamed": { en: "Unnamed ability", de: "Unbenannte Fähigkeit" },
    "game.actionPlaceholder": { en: "What do you attempt to do?", de: "Was versuchst du zu tun?" },
    "game.actions": { en: "Actions", de: "Aktionen" },
    "game.autoSubmitHint": { en: "Actions submit automatically after a brief pause.", de: "Aktionen werden nach einer kurzen Pause automatisch übermittelt." },
    "game.advanceCountdown": { en: "Advancing… {{seconds}}s", de: "Weiter … {{seconds}}s" },
    "game.condition.unnamed": { en: "Unnamed condition", de: "Unbenannter Zustand" },
    "game.dropZone": { en: "Drop here to create a new lane", de: "Hier ablegen, um eine neue Spalte zu erstellen" },
    "game.enterCountdown": { en: "Entering… {{seconds}}s", de: "Betrete … {{seconds}}s" },
    "game.inventory.unnamed": { en: "Unnamed item", de: "Unbenannter Gegenstand" },
    "game.lock.banner.busy": { en: "Busy…", de: "Beschäftigt …" },
    "game.lock.banner.generatingImage": { en: "Generating image…", de: "Bild wird erzeugt …" },
    "game.lock.banner.generatingImageCountdown": { en: "Generating image… {{seconds}}s", de: "Bild wird erzeugt … {{seconds}}s" },
    "game.lock.banner.generatingPortrait": { en: "Rendering portrait…", de: "Porträt wird gerendert …" },
    "game.lock.banner.generatingPortraitCountdown": { en: "Rendering portrait… {{seconds}}s", de: "Porträt wird gerendert … {{seconds}}s" },
    "game.lock.banner.generatingVideo": { en: "Rendering video…", de: "Video wird gerendert …" },
    "game.lock.banner.generatingVideoCountdown": { en: "Rendering video… {{seconds}}s", de: "Video wird gerendert … {{seconds}}s" },
    "game.lock.banner.resolving": { en: "Resolving turn…", de: "Runde wird ausgewertet …" },
    "game.lock.banner.resolvingCountdown": { en: "Resolving turn… {{seconds}}s", de: "Runde wird ausgewertet … {{seconds}}s" },
    "game.lock.reason.busy": { en: "Disabled while the GM is busy.", de: "Deaktiviert, während der SL beschäftigt ist." },
    "game.lock.reason.generatingImage": { en: "Disabled while image generation is in progress.", de: "Deaktiviert, während ein Bild erzeugt wird." },
    "game.lock.reason.generatingPortrait": { en: "Disabled while a portrait is rendering.", de: "Deaktiviert, während ein Porträt gerendert wird." },
    "game.lock.reason.generatingVideo": { en: "Disabled while a video is rendering.", de: "Deaktiviert, während ein Video gerendert wird." },
    "game.lock.reason.resolving": { en: "Disabled while the turn is being resolved.", de: "Deaktiviert, während die Runde ausgewertet wird." },
    "game.narrateOff": { en: "Narrate Off", de: "Erzählung aus" },
    "game.narrateOn": { en: "Narrate On", de: "Erzählung an" },
    "game.narration.blocked": { en: "Narration playback was blocked by the browser.", de: "Die Wiedergabe der Erzählung wurde vom Browser blockiert." },
    "game.narration.disableTitle": { en: "Disable ElevenLabs narration", de: "ElevenLabs-Erzählung deaktivieren" },
    "game.narration.enableTitle": { en: "Enable ElevenLabs narration", de: "ElevenLabs-Erzählung aktivieren" },
    "game.narration.error": { en: "ElevenLabs narration failed.", de: "ElevenLabs-Erzählung fehlgeschlagen." },
    "game.nextTurn": { en: "Next turn", de: "Nächste Runde" },
    "game.noAbility": { en: "no notable abilities", de: "keine besonderen Fähigkeiten" },
    "game.noCondition": { en: "no special conditions", de: "keine besonderen Zustände" },
    "game.noInventory": { en: "no carried gear", de: "keine getragene Ausrüstung" },
    "game.playerAction.none": { en: "No action submitted", de: "Noch keine Aktion übermittelt" },
    "game.playerAction.prefix": { en: "Submitted action: ", de: "Übermittelte Aktion: " },
    "game.playerFallback": { en: "Player", de: "Spieler" },
    "game.playerFlag.departing": { en: "departing after next turn", de: "verlässt nach der nächsten Runde" },
    "game.playerFlag.queued": { en: "queued to enter", de: "zum Beitritt vorgemerkt" },
    "game.playerTag.departing": { en: "departing next turn", de: "verlässt in der nächsten Runde" },
    "game.playerTag.joining": { en: "joining soon", de: "tritt bald bei" },
    "game.portrait.previewAlt": { en: "Player portrait preview", de: "Spielerportrait-Vorschau" },
    "game.portrait.previewWithPrompt": { en: "Portrait preview — {{prompt}}", de: "Porträtvorschau – {{prompt}}" },
    "game.portrait.turnaroundAlt": { en: "Character turnaround reference", de: "Charakter-Referenzansicht" },
    "game.portrait.turnaroundWithPrompt": { en: "Turnaround reference — {{prompt}}", de: "Referenzansicht – {{prompt}}" },
    "game.portrait.tooltip.generate": { en: "Click to generate your portrait.", de: "Klicke, um dein Porträt zu generieren." },
    "game.portrait.tooltip.hover": { en: "Hover to preview this portrait.", de: "Fahre mit der Maus über dieses Porträt, um eine Vorschau zu sehen." },
    "game.portrait.tooltip.lockedBusy": { en: "Portrait generation is paused while the GM is busy.", de: "Porträterstellung pausiert, während der SL beschäftigt ist." },
    "game.portrait.tooltip.lockedPreJoin": { en: "Portraits unlock after you join the adventure.", de: "Porträts werden nach deinem Beitritt freigeschaltet." },
    "game.portrait.tooltip.onlyOwner": { en: "Only this player can update their portrait.", de: "Nur dieser Spieler kann sein Porträt aktualisieren." },
    "game.portrait.ariaLabel": { en: "{{name}} portrait", de: "Porträt von {{name}}" },
    "game.portrait.tooltip.refresh": { en: "Click to refresh your portrait.", de: "Klicke, um dein Porträt zu aktualisieren." },
    "game.narrative": { en: "Narrative", de: "Erzählung" },
    "game.submit": { en: "Submit", de: "Absenden" },
    "game.turn": { en: "Turn {{count}}", de: "Runde {{count}}" },
    "game.waiting": { en: "Waiting…", de: "Warten …" },
    "devInfo.empty": { en: "No data recorded yet.", de: "Noch keine Daten vorhanden." },
    "devInfo.fetchError": { en: "Failed to load developer info.", de: "Entwicklerinformationen konnten nicht geladen werden." },
    "devInfo.request": { en: "Last request", de: "Letzte Anfrage" },
    "devInfo.response": { en: "Last response", de: "Letzte Antwort" },
    "devInfo.summaryRequestHeading": { en: "Summary request", de: "Zusammenfassungs-Anfrage" },
    "devInfo.summaryResponseHeading": { en: "Summary response", de: "Zusammenfassungs-Antwort" },
    "devInfo.turnRequestHeading": { en: "Turn request", de: "Rundenanfrage" },
    "devInfo.turnResponseHeading": { en: "Turn response", de: "Rundenantwort" },
    "devInfo.tip": { en: "Shows the most recent payload sent to the text model and everything it returned.", de: "Zeigt die zuletzt an das Textmodell gesendeten Daten sowie die komplette Antwort." },
    "devInfo.title": { en: "Text API exchange", de: "Text-API-Austausch" },
    "header.devInfo": { en: "Developer info", de: "Entwicklerinfo" },
    "header.settings": { en: "Settings", de: "Einstellungen" },
    "header.settingsCountdown": { en: "Opening… {{seconds}}s", de: "Öffne … {{seconds}}s" },
    "header.stats": { en: "Statistics", de: "Statistiken" },
    "header.fullscreenHint": { en: "Press\nF11", de: "Drücke\nF11" },
    "join.backgroundLabel": { en: "Short background (2–3 sentences)", de: "Kurzer Hintergrund (2–3 Sätze)" },
    "join.backgroundPlaceholder": { en: "Wizard", de: "Zauberer" },
    "join.countdown": { en: "Entering… {{seconds}}s", de: "Betrete … {{seconds}}s" },
    "join.enter": { en: "Enter World", de: "Welt betreten" },
    "join.eyebrow": { en: "Session Zero", de: "Session Null" },
    "join.hintConcise": { en: "Keep it concise so the GM can weave it into play quickly.", de: "Halte dich kurz, damit der Spielleiter schnell loslegen kann." },
    "join.hintTone": { en: "Hints about tone or motivation help tailor the opening scene.", de: "Hinweise zu Ton oder Motivation helfen, die Einstiegsszene anzupassen." },
    "join.hintWaiting": { en: "You'll start right away if no adventure is running; otherwise you'll appear after the next turn resolves.", de: "Du startest sofort, wenn kein Abenteuer läuft; sonst erscheinst du nach der nächsten Runde." },
    "join.nameLabel": { en: "Character name", de: "Charaktername" },
    "join.namePlaceholder": { en: "Hephaest", de: "Hephaest" },
    "join.status.creatingWorld": { en: "Creating your world. Hang tight while the opening scenario is prepared.", de: "Deine Welt wird erschaffen. Einen Moment Geduld, während die Einstiegsszene vorbereitet wird." },
    "join.status.invalidSession": { en: "Your session is no longer valid. Please rejoin.", de: "Deine Sitzung ist nicht mehr gültig. Bitte tritt erneut bei." },
    "join.status.preparing": { en: "Preparing your adventure. You'll enter as soon as the world is ready.", de: "Dein Abenteuer wird vorbereitet. Du startest, sobald die Welt bereit ist." },
    "join.status.queueActive": { en: "You're queued to join. The GM will bring you in after the next turn.", de: "Du stehst in der Warteschlange. Der SL holt dich nach der nächsten Runde hinein." },
    "join.status.queueAfterTurn": { en: "You're in the queue. Once the next turn resolves, your character will appear.", de: "Du bist in der Warteschlange. Sobald die nächste Runde abgeschlossen ist, erscheint dein Charakter." },
    "join.status.requestSent": { en: "Request sent. You'll join after the next turn resolves.", de: "Anfrage gesendet. Du trittst nach der nächsten Runde bei." },
    "join.status.restoring": { en: "Restoring session…", de: "Sitzung wird wiederhergestellt …" },
    "join.status.waitingActive": { en: "An adventure is in progress. You'll enter after the next turn resolves.", de: "Ein Abenteuer läuft. Du kommst nach der nächsten Runde dazu." },
    "join.status.waitingIdle": { en: "No adventure is running yet. The first player will start a new scenario immediately.", de: "Es läuft noch kein Abenteuer. Der erste Spieler startet sofort ein neues Szenario." },
    "join.status.waitingQueued": { en: "You're queued to join. Waiting for the next turn to resolve…", de: "Du stehst in der Warteschlange. Wartest auf den Abschluss der nächsten Runde …" },
    "join.subtitle": { en: "Sketch a name and origin so the game master can welcome your hero into the story.", de: "Skizziere einen Namen und eine Herkunft, damit der Spielleiter deinen Helden willkommen heißen kann." },
    "join.title": { en: "Forge your legend", de: "Schmiede deine Legende" },
    "language.label": { en: "Language", de: "Sprache" },
    "language.option.english": { en: "English", de: "Englisch" },
    "language.option.german": { en: "German", de: "Deutsch" },
    "sidebar.players": { en: "Players", de: "Spieler" },
    "sidebar.yourCharacter": { en: "Your character", de: "Dein Charakter" },
    "sidebar.abilities": { en: "Abilities", de: "Fähigkeiten" },
    "sidebar.inventory": { en: "Inventory", de: "Inventar" },
    "sidebar.conditions": { en: "Conditions", de: "Zustände" },
    "sidebar.sceneImage": { en: "Scene image", de: "Szenenbild" },
    "sidebar.autoImageOff": { en: "Auto Image Off", de: "Auto-Bild aus" },
    "sidebar.autoImageOn": { en: "Auto Image On", de: "Auto-Bild an" },
    "sidebar.autoImage.enableTitle": { en: "Enable automatic scene images", de: "Automatische Szenenbilder aktivieren" },
    "sidebar.autoImage.disableTitle": { en: "Disable automatic scene images", de: "Automatische Szenenbilder deaktivieren" },
    "sidebar.animateImage": { en: "Animate Image", de: "Bild animieren" },
    "sidebar.animateImageTitle": { en: "Animate the current scene image", de: "Aktuelles Szenenbild animieren" },
    "sidebar.autoVideoOff": { en: "Auto Animation Off", de: "Auto-Animation aus" },
    "sidebar.autoVideoOn": { en: "Auto Animation On", de: "Auto-Animation an" },
    "sidebar.autoVideo.enableTitle": { en: "Enable automatic scene animations", de: "Automatische Szenenanimationen aktivieren" },
    "sidebar.autoVideo.disableTitle": { en: "Disable automatic scene animations", de: "Automatische Szenenanimationen deaktivieren" },
    "settings.apiKeyPlaceholder": { en: "Paste your key…", de: "Schlüssel einfügen …" },
    "settings.close": { en: "Close settings", de: "Einstellungen schließen" },
    "settings.difficulty.label": { en: "Difficulty", de: "Schwierigkeit" },
    "settings.difficulty.option.easy": { en: "Easy", de: "Leicht" },
    "settings.difficulty.option.hard": { en: "Hard", de: "Schwer" },
    "settings.difficulty.option.impossible": { en: "Impossible", de: "Unmöglich" },
    "settings.difficulty.option.normal": { en: "Normal", de: "Normal" },
    "settings.difficulty.option.trivial": { en: "Trivial", de: "Trivial" },
    "settings.elevenKey.label": { en: "ElevenLabs API key", de: "ElevenLabs-API-Schlüssel" },
    "settings.geminiKey.label": { en: "Gemini API key", de: "Gemini-API-Schlüssel" },
    "settings.grokKey.label": { en: "Grok API key", de: "Grok-API-Schlüssel" },
    "settings.openaiKey.label": { en: "OpenAI API key", de: "OpenAI-API-Schlüssel" },
    "settings.imageModel.label": { en: "Image model", de: "Bildmodell" },
    "settings.videoModel.label": { en: "Video model", de: "Videomodell" },
    "settings.videoModel.savedSuffix": { en: "(saved)", de: "(gespeichert)" },
    "settings.videoLength.label": { en: "Video length", de: "Videolänge" },
    "settings.videoLength.suffix": { en: "seconds", de: "Sekunden" },
    "settings.videoLength.disabledTitle": { en: "Veo models generate fixed 8 second clips.", de: "Veo-Modelle erzeugen fest 8-sekündige Clips." },
    "settings.videoLength.tooltip": { en: "FramePack tip: a 1 second clip takes about 70 seconds to render.", de: "FramePack-Tipp: Ein 1-Sekunden-Clip benötigt etwa 70 Sekunden Renderzeit." },
    "settings.narrationModel.disabledTitle": { en: "Save a valid ElevenLabs API key to load narration models.", de: "Speichere einen gültigen ElevenLabs-API-Schlüssel, um Erzählmodelle zu laden." },
    "settings.narrationModel.enterKey": { en: "Enter ElevenLabs API key to load models", de: "Gib einen ElevenLabs-API-Schlüssel ein, um Modelle zu laden" },
    "settings.narrationModel.label": { en: "Narration model", de: "Erzählmodell" },
    "settings.narrationModel.savedSuffix": { en: "(saved)", de: "(gespeichert)" },
    "settings.save": { en: "Save changes", de: "Änderungen speichern" },
    "settings.section.access": { en: "Access", de: "Zugriff" },
    "settings.section.adventureTone": { en: "Adventure tone", de: "Abenteuerstimmung" },
    "settings.section.models": { en: "Models", de: "Modelle" },
    "settings.section.flow": { en: "Session flow & performance", de: "Spielablauf & Performance" },
    "settings.share.label": { en: "Players join via", de: "Spieler treten bei über" },
    "settings.textModel.label": { en: "Text model", de: "Textmodell" },
    "settings.thinking.label": { en: "Thinking mode", de: "Denkmodus" },
    "settings.thinking.option.balanced": { en: "Balanced", de: "Ausgewogen" },
    "settings.thinking.option.brief": { en: "Brief planning", de: "Kurze Planung" },
    "settings.thinking.option.deep": { en: "Deep reasoning", de: "Tiefes Nachdenken" },
    "settings.thinking.option.none": { en: "No thinking (fast)", de: "Kein Nachdenken (schnell)" },
    "settings.historyMode.summaryLabel": { en: "Send summary instead of full history", de: "Nur Zusammenfassung senden" },
    "settings.historyMode.summaryHint": {
      en: "When enabled, the GM receives a concise bullet summary in place of the full history each turn.",
      de: "Wenn aktiviert, erhält der Spielleiter pro Runde nur eine knappe Stichpunkt-Zusammenfassung statt des vollständigen Verlaufs."
    },
    "settings.fxSaver.label": {
      en: "FX Saver (disable blur effects)",
      de: "FX-Sparer (Weichzeichner deaktivieren)"
    },
    "settings.fxSaver.hint": {
      en: "Turn off blur and translucency to improve performance on weaker GPUs.",
      de: "Deaktiviert Unschärfe und Transparenz für bessere Leistung auf schwächeren GPUs."
    },
    "settings.title": { en: "Session Settings", de: "Sitzungseinstellungen" },
    "settings.worldStyle.label": { en: "World style", de: "Weltstil" },
    "settings.worldStyle.option.highFantasy": { en: "High fantasy", de: "High Fantasy" },
    "settings.worldStyle.option.lowFantasy": { en: "Low fantasy", de: "Low Fantasy" },
    "settings.worldStyle.option.scienceFantasy": { en: "Science fantasy", de: "Science-Fantasy" },
    "settings.worldStyle.option.scienceFiction": { en: "Science fiction", de: "Science-Fiction" },
    "settings.worldStyle.option.unicorns": { en: "Unicorns", de: "Einhörner" },
    "settings.worldStyle.option.cuteDogs": { en: "Cute dogs", de: "Süße Hunde" },
    "settings.worldStyle.option.fairyGarden": { en: "Fairy garden", de: "Feengarten" },
    "settings.worldStyle.option.custom": { en: "Custom…", de: "Benutzerdefiniert…" },
    "settings.worldStyle.customPlaceholder": { en: "Describe your world style", de: "Beschreibe deinen Weltstil" },
    "stats.image.avgCost": { en: "Average Cost Per Image", de: "Durchschnittliche Kosten pro Bild" },
    "stats.image.avgPrefix": { en: "avg", de: "Ø" },
    "stats.image.lastModel": { en: "Last Image Model", de: "Zuletzt genutztes Bildmodell" },
    "stats.image.sessionByType": { en: "Session Images by Type", de: "Bilder der Sitzung nach Typ" },
    "stats.image.sessionCost": { en: "Session Image Cost", de: "Bildkosten der Sitzung" },
    "stats.image.sessionCount": { en: "Session Images Generated", de: "In der Sitzung erstellte Bilder" },
    "stats.image.tip": { en: "Image pricing uses Gemini per-image rates (standard tier).", de: "Bildpreise basieren auf den Gemini-Kosten pro Bild (Standardtarif)." },
    "stats.image.type.portrait": { en: "portrait", de: "Porträt" },
    "stats.image.type.scene": { en: "scene", de: "Szene" },
    "stats.image.title": { en: "Image usage details", de: "Bildnutzung im Detail" },
    "stats.image.turnByType": { en: "This Turn Images by Type", de: "Bilder dieser Runde nach Typ" },
    "stats.image.turnCost": { en: "This Turn Image Cost", de: "Bildkosten dieser Runde" },
    "stats.video.title": { en: "Video usage details", de: "Videonutzung im Detail" },
    "stats.video.turnCost": { en: "This Turn Video Cost", de: "Videokosten dieser Runde" },
    "stats.video.sessionCost": { en: "Session Video Cost", de: "Videokosten der Sitzung" },
    "stats.video.lastModel": { en: "Last Video Model", de: "Letztes Videomodell" },
    "stats.video.lastSeconds": { en: "Last Video Duration (seconds)", de: "Letzte Videodauer (Sekunden)" },
    "stats.video.sessionSeconds": { en: "Session Video Duration", de: "Videodauer in der Sitzung" },
    "stats.video.usdPerSecond": { en: "USD per second", de: "USD pro Sekunde" },
    "stats.video.avgUsdPerSecond": { en: "Average USD per second", de: "Durchschn. USD pro Sekunde" },
    "stats.video.requests": { en: "Session Requests", de: "Anfragen in der Sitzung" },
    "stats.video.avgSecondsPerRequest": { en: "Average seconds per request", de: "Durchschn. Sekunden pro Anfrage" },
    "stats.video.tip": { en: "Video pricing uses Veo per-second rates for generated clips.", de: "Die Videokosten basieren auf den Veo-Preisen pro Sekunde für generierte Clips." },
    "stats.main.imageDetails": { en: "Image details", de: "Bilddetails" },
    "stats.main.videoDetails": { en: "Video details", de: "Videodetails" },
    "stats.main.narrationDetails": { en: "Narration details", de: "Erzähldetails" },
    "stats.main.textDetails": { en: "Text details", de: "Textdetails" },
    "stats.main.tip": { en: "Open a category to see token and cost breakdowns.", de: "Öffne eine Kategorie, um Token- und Kostenaufteilungen zu sehen." },
    "stats.main.title": { en: "Usage overview", de: "Nutzungsübersicht" },
    "stats.narration.lastChars": { en: "Last Turn Characters", de: "Zeichen letzte Runde" },
    "stats.narration.lastCredits": { en: "Last Turn Credits", de: "Credits letzte Runde" },
    "stats.narration.lastModel": { en: "Last Narration Model", de: "Zuletzt genutztes Erzählmodell" },
    "stats.narration.remainingCredits": { en: "Remaining Credits", de: "Verbleibende Credits" },
    "stats.narration.sessionChars": { en: "Session Characters", de: "Zeichen in der Sitzung" },
    "stats.narration.sessionCredits": { en: "Session Credits", de: "Credits der Sitzung" },
    "stats.narration.tip": { en: "Cost estimates use ElevenLabs response headers when available; otherwise we fall back to text length and official pricing.", de: "Kostenschätzungen verwenden, wenn verfügbar, die ElevenLabs-Antwortheader; andernfalls greifen wir auf Textlänge und offizielle Preise zurück." },
    "stats.narration.title": { en: "Narration usage details", de: "Erzählung im Detail" },
    "stats.narration.voiceId": { en: "Voice ID", de: "Stimmen-ID" },
    "stats.shared.close": { en: "Close", de: "Schließen" },
    "stats.shared.lastTurnCost": { en: "Last Turn Cost", de: "Kosten letzte Runde" },
    "stats.shared.sessionCost": { en: "Session Cost", de: "Kosten der Sitzung" },
    "stats.shared.sessionRequests": { en: "Session Requests", de: "Anfragen der Sitzung" },
    "stats.text.lastTokens": { en: "Last Turn Tokens (in / out / thinking)", de: "Tokens letzte Runde (rein / raus / Denken)" },
    "stats.text.lastTotal": { en: "Last Turn Total Tokens", de: "Token gesamt letzte Runde" },
    "stats.text.sessionTokens": { en: "Session Tokens (in / out / thinking)", de: "Tokens der Sitzung (rein / raus / Denken)" },
    "stats.text.sessionTotal": { en: "Session Total Tokens", de: "Token gesamt in der Sitzung" },
    "stats.text.throughput": { en: "Throughput", de: "Durchsatz" },
    "stats.text.rateUnit": { en: "tok/s", de: "Token/s" },
    "stats.text.tip": { en: "Token totals include thinking tokens when supported.", de: "Gesamttoken beinhalten Denk-Token, wenn verfügbar." },
    "stats.text.title": { en: "Text usage details", de: "Textnutzung im Detail" },
    "system.unexpectedError": { en: "An unexpected error occurred.", de: "Ein unerwarteter Fehler ist aufgetreten." },
  };


  function activeLanguage() {
    const lang = typeof state.language === 'string' ? state.language : DEFAULT_LANGUAGE;
    return SUPPORTED_LANGUAGES.includes(lang) ? lang : DEFAULT_LANGUAGE;
  }

  function formatTemplate(template, replacements) {
    if (!replacements || typeof replacements !== 'object') return template;
    return template.replace(/\{\{(\w+)\}\}/g, (match, token) => {
      if (!Object.prototype.hasOwnProperty.call(replacements, token)) return match;
      const value = replacements[token];
      return value === undefined || value === null ? '' : String(value);
    });
  }

  function t(key, replacements) {
    if (typeof key !== 'string' || !key) return '';
    const entry = TRANSLATIONS[key];
    const lang = activeLanguage();
    const template = entry ? (entry[lang] ?? entry.en ?? key) : key;
    return formatTemplate(template, replacements);
  }

  function loadStoredLanguage() {
    try {
      if (window.localStorage) {
        const stored = localStorage.getItem(LANGUAGE_STORAGE_KEY);
        if (stored && SUPPORTED_LANGUAGES.includes(stored)) {
          return stored;
        }
      }
    } catch (err) {
      /* ignore storage errors */
    }
    const docLang = (document.documentElement.getAttribute('lang') || '').toLowerCase();
    if (SUPPORTED_LANGUAGES.includes(docLang)) return docLang;
    return DEFAULT_LANGUAGE;
  }

  async function syncLanguageToServer(lang) {
    const normalized = SUPPORTED_LANGUAGES.includes(lang) ? lang : DEFAULT_LANGUAGE;
    if (lastLanguageSync === normalized) return;
    const body = { language: normalized };
    if (state.playerId && state.playerToken) {
      body.player_id = state.playerId;
      body.token = state.playerToken;
    }
    try {
      const resp = await fetch('/api/language', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!resp.ok) {
        const detail = await resp.text();
        throw new Error(detail || `HTTP ${resp.status}`);
      }
      lastLanguageSync = normalized;
    } catch (err) {
      console.warn('Failed to sync language with server', err);
    }
  }

  function setLanguage(lang, { persist = true, apply = true, notify = false } = {}) {
    const normalized = SUPPORTED_LANGUAGES.includes(lang) ? lang : DEFAULT_LANGUAGE;
    const changed = normalized !== state.language;
    state.language = normalized;
    if (persist) {
      try {
        if (window.localStorage) localStorage.setItem(LANGUAGE_STORAGE_KEY, normalized);
      } catch (err) {
        /* ignore storage errors */
      }
    }
    if (apply) {
      applyLanguage();
    }
    if (notify && (changed || lastLanguageSync !== normalized)) {
      syncLanguageToServer(normalized);
    }
  }

  function maybeUpdateJoinDefaults(lang) {
    const defaults = JOIN_DEFAULTS[lang] || JOIN_DEFAULTS[DEFAULT_LANGUAGE];
    const nameInput = $('name');
    const backgroundInput = $('background');
    let changed = false;
    if (nameInput && defaults && defaults.name) {
      const current = (nameInput.value || '').trim();
      if (!current || KNOWN_JOIN_NAMES.has(current)) {
        if (nameInput.value !== defaults.name) {
          nameInput.value = defaults.name;
          changed = true;
        }
      }
    }
    if (backgroundInput && defaults && defaults.background) {
      const currentBg = (backgroundInput.value || '').trim();
      if (!currentBg || KNOWN_JOIN_BACKGROUNDS.has(currentBg)) {
        if (backgroundInput.value !== defaults.background) {
          backgroundInput.value = defaults.background;
          changed = true;
        }
      }
    }
    if (changed) {
      rememberJoinInputs(nameInput ? nameInput.value : '', backgroundInput ? backgroundInput.value : '');
    }
  }

  function refreshPortraitTooltips() {
    const lockActive = Boolean(state.lock && state.lock.active);
    document.querySelectorAll('.player-portrait').forEach((btn) => {
      updatePortraitButtonState(btn, lockActive);
    });
  }

  function updateTurnHeader(value) {
    const turnHeaderEl = $('turnHeader');
    if (!turnHeaderEl) return;
    const numeric = Number.isFinite(value) ? value : 0;
    turnHeaderEl.textContent = t('game.turn', { count: numeric });
    state.currentTurn = numeric;
  }

  function applyLanguage() {
    const lang = typeof state.language === 'string' ? state.language : DEFAULT_LANGUAGE;
    state.language = SUPPORTED_LANGUAGES.includes(lang) ? lang : DEFAULT_LANGUAGE;
    document.documentElement.setAttribute('lang', state.language);
    document.documentElement.setAttribute('dir', 'ltr');
    const selector = $('languageSelect');
    if (selector && selector.value !== state.language) {
      selector.value = state.language;
    }
    document.querySelectorAll('[data-i18n]').forEach((el) => {
      const key = el.dataset.i18n;
      if (!key) return;
      const text = t(key);
      if (typeof text === 'string') {
        el.textContent = text;
        if (el.tagName === 'BUTTON') {
          el.dataset.defaultLabel = text;
        }
      }
    });
    document.querySelectorAll('[data-i18n-attr]').forEach((el) => {
      const attrSpec = el.dataset.i18nAttr;
      if (!attrSpec) return;
      attrSpec.split(',').forEach((segment) => {
        const parts = segment.split(':');
        if (parts.length < 2) return;
        const attr = parts[0].trim();
        const key = parts.slice(1).join(':').trim();
        if (!attr || !key) return;
        const text = t(key);
        if (typeof text === 'string') {
          el.setAttribute(attr, text);
          if (attr === 'placeholder') {
            el.dataset.defaultLabel = text;
          }
        }
      });
    });
    document.querySelectorAll('[data-i18n-option]').forEach((opt) => {
      const key = opt.dataset.i18nOption;
      if (!key) return;
      const text = t(key);
      if (typeof text === 'string') {
        opt.textContent = text;
      }
    });
    if (worldStyleMenuInitialized) {
      const menu = $('worldStyleMenu');
      const currentSelect = $('setWorld');
      if (menu && currentSelect) {
        const currentValue = currentSelect.value;
        closeWorldStyleMenu({ silentFocus: true });
        renderWorldStyleMenu(menu);
        updateWorldMenuSelection(currentValue);
        updateWorldPickerDisplay(currentValue);
      }
    }
    maybeUpdateJoinDefaults(state.language);
    buttonCountdowns.forEach((entry, id) => {
      const btn = $(id);
      if (btn) {
        entry.defaultLabel = (btn.textContent || '').trim();
        buttonCountdowns.set(id, entry);
      }
    });
    if (state.joinStatusKey) {
      updateJoinStatus('', { key: state.joinStatusKey, args: state.joinStatusArgs || {} });
    }
    const narrativeEl = $('narrative');
    if (narrativeEl && !narrativeEl.dataset.historyReady) {
      const trimmed = (narrativeEl.textContent || '').trim();
      const waitingEn = TRANSLATIONS['game.waiting'] ? TRANSLATIONS['game.waiting'].en : 'Waiting…';
      const waitingDe = TRANSLATIONS['game.waiting'] ? TRANSLATIONS['game.waiting'].de : 'Warten …';
      if (!trimmed || trimmed === waitingEn || trimmed === waitingDe) {
        narrativeEl.textContent = t('game.waiting');
      }
    }
    if (state.lastPublic) {
      renderPublic(state.lastPublic);
    } else {
      refreshJoinGuidance();
      syncNarrationToggle(state.autoTtsEnabled);
      setLockBanner(state.lock || { active: false, reason: '' });
      updateTurnHeader(state.currentTurn);
      refreshPortraitTooltips();
    }
    if (state.lastPrivate) {
      renderPrivate(state.lastPrivate);
    }

    syncFullscreenHint();
  }

  function initLanguage() {
    const stored = loadStoredLanguage();
    setLanguage(stored, { persist: false, apply: true });
  }

  let systemNoticeTimer = null;
  const buttonCountdowns = new Map();

  const lockBannerCountdownKeys = {
    resolving_turn: 'game.lock.banner.resolvingCountdown',
    generating_image: 'game.lock.banner.generatingImageCountdown',
    generating_portrait: 'game.lock.banner.generatingPortraitCountdown',
    generating_video: 'game.lock.banner.generatingVideoCountdown',
  };

  const lockBannerCountdownState = {
    timer: null,
    reason: '',
    start: 0,
    banner: null,
    translationKey: '',
  };

  function stopLockBannerCountdown() {
    if (lockBannerCountdownState.timer) {
      clearInterval(lockBannerCountdownState.timer);
      lockBannerCountdownState.timer = null;
    }
    lockBannerCountdownState.reason = '';
    lockBannerCountdownState.start = 0;
    lockBannerCountdownState.banner = null;
    lockBannerCountdownState.translationKey = '';
  }

  function updateLockBannerCountdown() {
    const { banner, translationKey, start } = lockBannerCountdownState;
    if (!banner || !translationKey || !start) return;
    const elapsed = Date.now() - start;
    const seconds = Math.max(1, Math.floor(elapsed / 1000) + 1);
    banner.textContent = t(translationKey, { seconds });
  }

  function ensureLockBannerCountdown(banner, reason) {
    const translationKey = lockBannerCountdownKeys[reason];
    if (!translationKey) {
      stopLockBannerCountdown();
      return false;
    }
    if (lockBannerCountdownState.timer && lockBannerCountdownState.reason === reason) {
      lockBannerCountdownState.banner = banner;
      lockBannerCountdownState.translationKey = translationKey;
      updateLockBannerCountdown();
      return true;
    }
    stopLockBannerCountdown();
    lockBannerCountdownState.reason = reason || '';
    lockBannerCountdownState.banner = banner || null;
    lockBannerCountdownState.translationKey = translationKey;
    lockBannerCountdownState.start = Date.now();
    updateLockBannerCountdown();
    lockBannerCountdownState.timer = setInterval(updateLockBannerCountdown, 1000);
    return true;
  }

  function syncFullscreenHint() {
    const hint = $('fullscreenHint');
    if (hint) {
      hint.classList.remove('hidden');
    }
  }

  ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach((eventName) => {
    document.addEventListener(eventName, syncFullscreenHint);
  });

  window.addEventListener('resize', syncFullscreenHint);
  window.addEventListener('orientationchange', syncFullscreenHint);

  initLanguage();

  syncFullscreenHint();

  function startButtonCountdown(id, renderLabel) {
    const btn = $(id);
    if (!btn) return;
    const entry = buttonCountdowns.get(id) || {};
    if (!entry.defaultLabel) {
      const raw = (btn.textContent || '').trim();
      entry.defaultLabel = raw || btn.dataset.defaultLabel || t('common.working');
    }
    entry.start = Date.now();
    entry.active = true;
    entry.render = typeof renderLabel === 'function'
      ? renderLabel
      : (seconds) => t('common.workingCountdown', { seconds });

    const updateLabel = () => {
      if (!entry.active) return;
      const now = Date.now();
      const base = typeof entry.start === 'number' ? entry.start : now;
      const elapsed = now - base;
      const seconds = Math.max(1, Math.floor(elapsed / 1000) + 1);
      const text = entry.render(seconds);
      if (typeof text === 'string') {
        btn.textContent = text;
      }
    };

    if (entry.timer) {
      clearInterval(entry.timer);
    }
    updateLabel();
    entry.timer = setInterval(updateLabel, 1000);
    buttonCountdowns.set(id, entry);
  }

  function stopButtonCountdown(id) {
    const entry = buttonCountdowns.get(id);
    if (!entry) return;
    entry.active = false;
    if (entry.timer) {
      clearInterval(entry.timer);
      entry.timer = null;
    }
    const btn = $(id);
    if (btn && entry.defaultLabel) {
      btn.textContent = entry.defaultLabel;
    }
    buttonCountdowns.set(id, entry);
  }

  function showSystemNotice(message, kind = 'info') {
    const fallback = t('system.unexpectedError');
    const normalized = (typeof message === 'string' ? message.trim() : '') || fallback;
    const el = $("systemNotice");
    if (!el) {
      if (kind === 'error') alert(normalized);
      return;
    }
    el.dataset.kind = kind;
    el.className = `system-notice ${kind}`;
    el.textContent = normalized;
    el.style.display = 'block';
    if (kind === 'error') {
      el.setAttribute('role', 'alert');
      el.setAttribute('aria-live', 'assertive');
    } else {
      el.setAttribute('role', 'status');
      el.setAttribute('aria-live', 'polite');
    }
    if (systemNoticeTimer) {
      clearTimeout(systemNoticeTimer);
    }
    systemNoticeTimer = setTimeout(() => {
      hideSystemNotice();
    }, 8000);
  }

  function hideSystemNotice(kind) {
    const el = $("systemNotice");
    if (!el) return;
    if (kind && el.dataset && el.dataset.kind && el.dataset.kind !== kind) return;
    el.style.display = 'none';
    el.textContent = '';
    if (el.dataset) delete el.dataset.kind;
    el.className = 'system-notice info';
    el.setAttribute('role', 'status');
    el.setAttribute('aria-live', 'polite');
    if (systemNoticeTimer) {
      clearTimeout(systemNoticeTimer);
      systemNoticeTimer = null;
    }
  }

  function getNarrativeBlock(turnNumber, createIfMissing = false) {
    const narrativeEl = $("narrative");
    if (!narrativeEl) return null;
    const key = typeof turnNumber === 'number' && Number.isFinite(turnNumber) ? turnNumber : 0;
    let block = narrativeEl.querySelector(`[data-turn="${key}"]`);
    if (!block && createIfMissing) {
      if (!narrativeEl.dataset.historyReady) {
        narrativeEl.textContent = '';
        narrativeEl.classList.remove('muted');
        narrativeEl.dataset.historyReady = '1';
      }
      block = document.createElement('div');
      block.className = 'narrative-block';
      block.dataset.turn = String(key);
      narrativeEl.insertBefore(block, narrativeEl.firstChild);
    }
    return block;
  }

  function renderNarrativeHistory(history) {
    const narrativeEl = $("narrative");
    if (!narrativeEl) return;
    const entries = Array.isArray(history) ? history : [];
    if (!entries.length) {
      if (narrativeEl.dataset.historyHydrated) {
        narrativeEl.textContent = t('game.waiting');
        narrativeEl.classList.add('muted');
        delete narrativeEl.dataset.historyReady;
        delete narrativeEl.dataset.historyHydrated;
      }
      return;
    }

    const seenTurns = new Set();
    entries.forEach((entry) => {
      if (!entry || typeof entry !== 'object') return;
      const rawTurn = entry.turn ?? entry.index ?? entry.turn_index;
      const turnNumber = Number(rawTurn);
      if (!Number.isFinite(turnNumber)) return;
      const narrativeText = typeof entry.narrative === 'string' ? entry.narrative : '';
      const hasText = narrativeText.trim().length > 0;
      const block = getNarrativeBlock(turnNumber, true);
      if (!block) return;
      block.textContent = hasText ? narrativeText : '—';
      if (entry.timestamp != null) {
        block.dataset.timestamp = String(entry.timestamp);
      } else if (block.dataset.timestamp) {
        delete block.dataset.timestamp;
      }
      seenTurns.add(String(turnNumber));
    });

    const blocks = Array.from(narrativeEl.querySelectorAll('.narrative-block'));
    blocks.forEach((block) => {
      const key = block.dataset.turn || '';
      if (!seenTurns.has(key)) {
        block.remove();
      }
    });

    narrativeEl.dataset.historyHydrated = '1';
  }

  function narrativeIsPinnedToTop(el, threshold = 24) {
    if (!el) return false;
    if (el.scrollHeight <= el.clientHeight) return true;
    return el.scrollTop <= threshold;
  }

  function scrollNarrativeToTop() {
    const narrativeEl = $("narrative");
    if (!narrativeEl) return;
    requestAnimationFrame(() => {
      narrativeEl.scrollTop = 0;
    });
  }

  function syncNarrationToggle(enabled) {
    state.autoTtsEnabled = Boolean(enabled);
    const btn = $("btnNarration");
    if (!btn) return;
    const active = Boolean(enabled);
    btn.setAttribute("aria-pressed", active ? "true" : "false");
    btn.classList.toggle("active", active);
    btn.textContent = active ? t('game.narrateOn') : t('game.narrateOff');
    btn.title = active ? t('game.narration.disableTitle') : t('game.narration.enableTitle');
    btn.disabled = !state.playerId;
    if (!active && narrationState.current) {
      try { narrationState.current.pause(); } catch (err) { /* ignore */ }
      narrationState.current.src = '';
      narrationState.current = null;
    }
    if (!active) {
      hideSystemNotice('error');
    }
  }

  function syncSceneImageToggle(enabled) {
    state.autoImageEnabled = Boolean(enabled);
    const btn = $("btnCreateImage");
    if (!btn) return;
    const active = Boolean(enabled);
    btn.setAttribute("aria-pressed", active ? "true" : "false");
    btn.classList.toggle("active", active);
    btn.textContent = active ? t('sidebar.autoImageOn') : t('sidebar.autoImageOff');
    btn.title = active ? t('sidebar.autoImage.disableTitle') : t('sidebar.autoImage.enableTitle');
    const busy = Boolean(state.lock && state.lock.active);
    btn.disabled = !state.playerId || busy;
  }

  function syncSceneVideoToggle(enabled) {
    state.autoVideoEnabled = Boolean(enabled);
    const btn = $("btnAnimateScene");
    if (!btn) return;
    const active = Boolean(enabled);
    btn.setAttribute("aria-pressed", active ? "true" : "false");
    btn.classList.toggle("active", active);
    btn.textContent = active ? t('sidebar.autoVideoOn') : t('sidebar.autoVideoOff');
    btn.title = active ? t('sidebar.autoVideo.disableTitle') : t('sidebar.autoVideo.enableTitle');
    const busy = Boolean(state.lock && state.lock.active);
    btn.disabled = !state.playerId || busy;
  }

  function setupSceneVideoPersistence() {
    const videoEl = $("sceneVideo");
    if (!videoEl || videoEl.dataset.sceneVideoHandlers === 'true') return;

    videoEl.dataset.sceneVideoHandlers = 'true';

    videoEl.addEventListener('play', () => {
      state.sceneVideoUserPaused = false;
      delete videoEl.dataset.userPaused;
    });

    videoEl.addEventListener('pause', () => {
      if (ignoreSceneVideoPause) return;
      if (!videoEl.dataset.baseUrl) return;
      if (videoEl.ended) return;
      state.sceneVideoUserPaused = true;
      videoEl.dataset.userPaused = 'true';
    });

    videoEl.addEventListener('ended', () => {
      state.sceneVideoUserPaused = false;
      delete videoEl.dataset.userPaused;
    });
  }

  function ensureSceneVideoAutoplays(videoEl) {
    if (!videoEl) return;
    if (state.sceneVideoUserPaused) return;
    videoEl.autoplay = true;
    if (!videoEl.hasAttribute('autoplay')) {
      videoEl.setAttribute('autoplay', '');
    }
    if (typeof videoEl.play !== 'function') return;
    const handleAutoplayFailure = (err) => {
      console.warn('Scene video autoplay blocked, retrying muted.', err);
      videoEl.dataset.autoplayMuted = 'true';
      videoEl.defaultMuted = true;
      videoEl.muted = true;
      if (!videoEl.hasAttribute('muted')) {
        videoEl.setAttribute('muted', '');
      }
      const mutedPlay = videoEl.play();
      if (mutedPlay && typeof mutedPlay.catch === 'function') {
        mutedPlay.catch((innerErr) => {
          console.warn('Scene video muted autoplay failed.', innerErr);
        });
      }
    };
    const playAttempt = videoEl.play();
    if (playAttempt && typeof playAttempt.then === 'function') {
      playAttempt
        .then(() => {
          if (videoEl.dataset.autoplayMuted === 'true') {
            delete videoEl.dataset.autoplayMuted;
          }
        })
        .catch(handleAutoplayFailure);
    } else if (playAttempt && typeof playAttempt.catch === 'function') {
      playAttempt.catch(handleAutoplayFailure);
    }
  }

  function narrativeIsActive() {
    const pub = state.lastPublic;
    if (!pub) return false;
    const narrativeText = typeof pub.current_narrative === 'string' ? pub.current_narrative.trim() : '';
    if (narrativeText) return true;
    return typeof pub.turn_index === 'number' && pub.turn_index > 0;
  }

  function refreshJoinGuidance() {
    const hint = $("joinHint");
    if (!hint) return;
    if (narrativeIsActive()) {
      hint.textContent = t('join.status.waitingActive');
    } else {
      hint.textContent = t('join.status.waitingIdle');
    }
  }
  const PLAYER_STORAGE_KEY = 'orpg-player-session';

  function getStoredPlayer() {
    try {
      const raw = window.localStorage ? localStorage.getItem(PLAYER_STORAGE_KEY) : null;
      return raw ? JSON.parse(raw) : null;
    } catch (err) {
      return null;
    }
  }

  function setStoredPlayer(data) {
    if (!window.localStorage) return;
    try {
      if (!data) localStorage.removeItem(PLAYER_STORAGE_KEY);
      else localStorage.setItem(PLAYER_STORAGE_KEY, JSON.stringify(data));
    } catch (err) {
      /* ignore storage errors */
    }
  }

  function rememberJoinInputs(name, background, reset = false) {
    const normalized = {
      name: name || '',
      background: background || ''
    };
    if (reset) {
      setStoredPlayer(normalized);
      return;
    }
    const existing = getStoredPlayer();
    if (!existing) {
      setStoredPlayer(normalized);
      return;
    }
    setStoredPlayer({
      ...existing,
      ...normalized,
    });
  }

  function persistPlayerSession(details) {
    if (!details || !details.token) return;
    const normalizedId = normalizeId(details.id);
    if (!normalizedId) return;
    const existing = getStoredPlayer() || {};
    const next = {
      ...existing,
      id: normalizedId,
      token: details.token,
      name: details.name || existing.name || '',
      background: details.background || existing.background || '',
    };
    if (typeof details.pending === 'boolean') {
      next.pending = details.pending;
    }
    setStoredPlayer(next);
  }

  function applyStoredJoinInputs(info) {
    if (!info) return;
    if (typeof info.name === 'string' && $("name")) $("name").value = info.name;
    if (typeof info.background === 'string' && $("background")) $("background").value = info.background;
  }

  function updateJoinStatus(text, options = {}) {
    const el = $("joinStatus");
    if (!el) return;
    const key = options.key;
    const args = options.args;
    const hasKey = Boolean(key);
    if (hasKey && HIDDEN_JOIN_STATUS_KEYS.has(key)) {
      el.textContent = "";
      el.style.display = "none";
      state.joinStatusKey = null;
      state.joinStatusArgs = null;
      return;
    }
    const message = hasKey ? t(key, args) : text;
    if (!message) {
      el.textContent = "";
      el.style.display = "none";
      state.joinStatusKey = null;
      state.joinStatusArgs = null;
      return;
    }
    el.textContent = message;
    el.style.display = "";
    state.joinStatusKey = hasKey ? key : null;
    state.joinStatusArgs = hasKey ? (args || {}) : null;
  }

  function setJoinWaiting(waiting) {
    const btn = $("btnEnter");
    const nameInput = $("name");
    const backgroundInput = $("background");
    [btn, nameInput, backgroundInput].forEach((el) => {
      if (!el) return;
      if (waiting) el.setAttribute("disabled", "true");
      else el.removeAttribute("disabled");
    });
    if (!waiting) {
      stopButtonCountdown('btnEnter');
    }
  }

  function handleJoinState(pending) {
    if (!state.playerId || !state.playerToken) return;
    state.pendingJoin = pending;
    if (pending) {
      if (narrativeIsActive()) {
        updateJoinStatus('', { key: 'join.status.queueActive' });
      } else {
        updateJoinStatus('', { key: 'join.status.preparing' });
      }
      showJoinView();
      setJoinWaiting(true);
    } else {
      updateJoinStatus('');
      setJoinWaiting(false);
      showGameView();
    }
    refreshJoinGuidance();
    persistPlayerSession({
      id: state.playerId,
      token: state.playerToken,
      name: state.playerName,
      background: state.playerBackground,
      pending,
    });
  }

  function showGameView() {
    stopJoinMusic({ resetQueue: true, fadeDurationMs: JOIN_MUSIC_FADE_DURATION_MS });
    if (document && document.body) document.body.classList.remove('join-screen');
    cancelJoinDrag();
    const joinView = $("joinView");
    if (joinView) joinView.style.display = "none";
    if ($("gameView")) $("gameView").style.display = "";
    if ($("side")) $("side").style.display = "";
    const statsBtn = $("btnStats");
    const devBtn = $("btnDevInfo");
    if (statsBtn) statsBtn.style.display = "";
    if (devBtn) devBtn.style.display = "";
  }

  function showJoinView() {
    loadJoinBackgrounds();
    if (!state.joinBackgroundUrl) {
      state.joinBackgroundUrl = pickJoinBackground();
    }
    applyJoinBackground(state.joinBackgroundUrl);
    if (document && document.body) document.body.classList.add('join-screen');
    const joinView = $("joinView");
    if (joinView) {
      joinView.style.display = "";
      joinView.classList.remove('dragging');
      if (!joinDragState.dragged) {
        joinView.style.top = "8vh";
        joinView.style.left = "50%";
        joinView.style.right = "";
        joinView.style.bottom = "";
        joinView.style.transform = "translateX(-50%)";
      }
    }
    if ($("gameView")) $("gameView").style.display = "none";
    if ($("side")) $("side").style.display = "none";
    const statsBtn = $("btnStats");
    const devBtn = $("btnDevInfo");
    if (statsBtn) statsBtn.style.display = "none";
    if (devBtn) devBtn.style.display = "none";
    initJoinDrag();
    syncJoinViewModalVisibility();
    ensureJoinMusic();
    armJoinMusicUnlock();
  }

  function cancelJoinDrag() {
    if (joinDragState.detachMouse) joinDragState.detachMouse();
    if (joinDragState.detachTouch) joinDragState.detachTouch();
    joinDragState.dragging = false;
    const joinView = $("joinView");
    if (joinView) joinView.classList.remove('dragging');
  }

  function initJoinDrag() {
    if (joinDragState.initialized) return;
    const joinView = $("joinView");
    if (!joinView) return;
    const handle = joinView.querySelector('.join-card-header');
    if (!handle) return;
    joinDragState.initialized = true;

    const updatePosition = (clientX, clientY) => {
      if (!joinDragState.dragging) return;
      const maxLeft = Math.max(window.innerWidth - joinDragState.width, 0);
      const maxTop = Math.max(window.innerHeight - joinDragState.height, 0);
      const nextLeft = Math.min(Math.max(clientX - joinDragState.offsetX, 0), maxLeft);
      const nextTop = Math.min(Math.max(clientY - joinDragState.offsetY, 0), maxTop);
      joinView.style.left = `${nextLeft}px`;
      joinView.style.top = `${nextTop}px`;
    };

    const finishDrag = () => {
      if (!joinDragState.dragging) return;
      joinDragState.dragging = false;
      joinView.classList.remove('dragging');
      if (joinDragState.detachMouse) joinDragState.detachMouse();
      if (joinDragState.detachTouch) joinDragState.detachTouch();
    };

    const onMouseMove = (event) => updatePosition(event.clientX, event.clientY);
    const onMouseUp = () => {
      finishDrag();
    };
    const onMouseDown = (event) => {
      if (event.button !== 0) return;
      const rect = joinView.getBoundingClientRect();
      joinDragState.dragging = true;
      joinDragState.dragged = true;
      joinDragState.offsetX = event.clientX - rect.left;
      joinDragState.offsetY = event.clientY - rect.top;
      joinDragState.width = rect.width;
      joinDragState.height = rect.height;
      joinView.style.transform = 'none';
      joinView.style.left = `${rect.left}px`;
      joinView.style.top = `${rect.top}px`;
      joinView.style.right = '';
      joinView.style.bottom = '';
      joinView.classList.add('dragging');
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      event.preventDefault();
    };

    const onTouchMove = (event) => {
      if (!event.touches || !event.touches.length) return;
      const touch = event.touches[0];
      updatePosition(touch.clientX, touch.clientY);
      event.preventDefault();
    };
    const onTouchEnd = () => {
      finishDrag();
    };
    const onTouchStart = (event) => {
      if (!event.touches || !event.touches.length) return;
      const touch = event.touches[0];
      const rect = joinView.getBoundingClientRect();
      joinDragState.dragging = true;
      joinDragState.dragged = true;
      joinDragState.offsetX = touch.clientX - rect.left;
      joinDragState.offsetY = touch.clientY - rect.top;
      joinDragState.width = rect.width;
      joinDragState.height = rect.height;
      joinView.style.transform = 'none';
      joinView.style.left = `${rect.left}px`;
      joinView.style.top = `${rect.top}px`;
      joinView.style.right = '';
      joinView.style.bottom = '';
      joinView.classList.add('dragging');
      document.addEventListener('touchmove', onTouchMove, { passive: false });
      document.addEventListener('touchend', onTouchEnd);
      document.addEventListener('touchcancel', onTouchEnd);
      event.preventDefault();
    };

    joinDragState.detachMouse = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    joinDragState.detachTouch = () => {
      document.removeEventListener('touchmove', onTouchMove);
      document.removeEventListener('touchend', onTouchEnd);
      document.removeEventListener('touchcancel', onTouchEnd);
    };

    handle.addEventListener('mousedown', onMouseDown);
    handle.addEventListener('touchstart', onTouchStart, { passive: false });

    const ensureWithinBounds = () => {
      if (!joinDragState.dragged) return;
      const rect = joinView.getBoundingClientRect();
      const maxLeft = Math.max(window.innerWidth - rect.width, 0);
      const maxTop = Math.max(window.innerHeight - rect.height, 0);
      const currentLeft = parseFloat(joinView.style.left || rect.left);
      const currentTop = parseFloat(joinView.style.top || rect.top);
      const nextLeft = Math.min(Math.max(currentLeft, 0), maxLeft);
      const nextTop = Math.min(Math.max(currentTop, 0), maxTop);
      joinView.style.left = `${nextLeft}px`;
      joinView.style.top = `${nextTop}px`;
      joinDragState.width = rect.width;
      joinDragState.height = rect.height;
    };

    window.addEventListener('resize', ensureWithinBounds);
  }

  function normalizeKeyPart(value) {
    if (typeof value === 'string') {
      return value.trim();
    }
    if (value === null || value === undefined) {
      return '';
    }
    return String(value).trim();
  }

  function abilityKey(ability) {
    if (!ability || typeof ability !== 'object') {
      return `raw:${normalizeKeyPart(ability)}`;
    }
    const name = normalizeKeyPart(ability.n);
    const extra = normalizeKeyPart(ability.x);
    return `n:${name}|x:${extra}`;
  }

  function textEntryKey(value) {
    return `text:${normalizeKeyPart(value)}`;
  }

  function resetHighlightBucket(mapRef) {
    if (mapRef && mapRef instanceof Map) {
      mapRef.clear();
      return mapRef;
    }
    return new Map();
  }

  function ensureHighlightStateTurn(turn) {
    const current = Number.isFinite(turn) ? turn : 0;
    if (!state.youHighlights || typeof state.youHighlights !== 'object') {
      state.youHighlights = {
        turn: current,
        abilities: new Map(),
        inventory: new Map(),
        conditions: new Map(),
      };
      return state.youHighlights;
    }
    const highlights = state.youHighlights;
    if (highlights.turn !== current) {
      highlights.turn = current;
      highlights.abilities = resetHighlightBucket(highlights.abilities);
      highlights.inventory = resetHighlightBucket(highlights.inventory);
      highlights.conditions = resetHighlightBucket(highlights.conditions);
    } else {
      if (!(highlights.abilities instanceof Map)) highlights.abilities = new Map();
      if (!(highlights.inventory instanceof Map)) highlights.inventory = new Map();
      if (!(highlights.conditions instanceof Map)) highlights.conditions = new Map();
    }
    return highlights;
  }

  function mergeHighlightCounts(target, additions) {
    if (!(target instanceof Map) || !(additions instanceof Map)) return;
    additions.forEach((count, key) => {
      if (!key || !Number.isFinite(count) || count <= 0) return;
      target.set(key, (target.get(key) || 0) + count);
    });
  }

  function cloneHighlightMap(source) {
    if (!(source instanceof Map) || source.size === 0) return null;
    return new Map(source);
  }

  function computeAddedCounts(previousItems, nextItems, keyFn) {
    if (!Array.isArray(nextItems) || typeof keyFn !== 'function') {
      return new Map();
    }
    const prevCounts = new Map();
    if (Array.isArray(previousItems)) {
      previousItems.forEach((item) => {
        const key = keyFn(item);
        if (!key) return;
        prevCounts.set(key, (prevCounts.get(key) || 0) + 1);
      });
    }
    const addedCounts = new Map();
    nextItems.forEach((item) => {
      const key = keyFn(item);
      if (!key) return;
      const prevCount = prevCounts.get(key) || 0;
      if (prevCount > 0) {
        prevCounts.set(key, prevCount - 1);
      } else {
        addedCounts.set(key, (addedCounts.get(key) || 0) + 1);
      }
    });
    return addedCounts;
  }

  function createHighlightConsumer(addedCounts) {
    if (!(addedCounts instanceof Map) || addedCounts.size === 0) {
      return null;
    }
    return (key) => {
      if (!key) return false;
      const count = addedCounts.get(key);
      if (!count) return false;
      if (count <= 1) {
        addedCounts.delete(key);
      } else {
        addedCounts.set(key, count - 1);
      }
      return true;
    };
  }

  function ensureRemovalStateTurn(turn) {
    const current = Number.isFinite(turn) ? turn : 0;
    if (!state.youRemovals || typeof state.youRemovals !== 'object') {
      state.youRemovals = {
        turn: current,
        abilities: new Map(),
        inventory: new Map(),
        conditions: new Map(),
      };
      return state.youRemovals;
    }
    const removals = state.youRemovals;
    if (removals.turn !== current) {
      removals.turn = current;
      removals.abilities = resetHighlightBucket(removals.abilities);
      removals.inventory = resetHighlightBucket(removals.inventory);
      removals.conditions = resetHighlightBucket(removals.conditions);
    } else {
      if (!(removals.abilities instanceof Map)) removals.abilities = new Map();
      if (!(removals.inventory instanceof Map)) removals.inventory = new Map();
      if (!(removals.conditions instanceof Map)) removals.conditions = new Map();
    }
    return removals;
  }

  function pruneRemovalEntries(target, currentItems, keyFn) {
    if (!(target instanceof Map) || typeof keyFn !== 'function') return;
    if (!Array.isArray(currentItems) || currentItems.length === 0) return;
    const currentCounts = new Map();
    currentItems.forEach((item) => {
      const key = keyFn(item);
      if (!key) return;
      currentCounts.set(key, (currentCounts.get(key) || 0) + 1);
    });
    target.forEach((data, key) => {
      if (!data || typeof data.count !== 'number') {
        target.delete(key);
        return;
      }
      const currentCount = currentCounts.get(key) || 0;
      if (currentCount <= 0) return;
      if (currentCount >= data.count) {
        target.delete(key);
      } else {
        data.count -= currentCount;
        target.set(key, data);
      }
    });
  }

  function mergeRemovalEntries(target, additions) {
    if (!(target instanceof Map) || !(additions instanceof Map)) return;
    additions.forEach((data, key) => {
      if (!key || !data || typeof data.count !== 'number' || data.count <= 0) return;
      const existing = target.get(key);
      if (existing && typeof existing.count === 'number') {
        existing.count += data.count;
        existing.item = data.item;
        target.set(key, existing);
      } else {
        target.set(key, { count: data.count, item: data.item });
      }
    });
  }

  function cloneRemovalEntries(source) {
    if (!(source instanceof Map) || source.size === 0) return null;
    return Array.from(source.entries()).map(([key, data]) => ({
      key,
      count: typeof data.count === 'number' && data.count > 0 ? data.count : 1,
      item: data.item,
    }));
  }

  function computeRemovedEntries(previousItems, nextItems, keyFn) {
    if (!Array.isArray(previousItems) || typeof keyFn !== 'function') {
      return new Map();
    }
    const nextCounts = new Map();
    if (Array.isArray(nextItems)) {
      nextItems.forEach((item) => {
        const key = keyFn(item);
        if (!key) return;
        nextCounts.set(key, (nextCounts.get(key) || 0) + 1);
      });
    }
    const removed = new Map();
    previousItems.forEach((item) => {
      const key = keyFn(item);
      if (!key) return;
      const remaining = nextCounts.get(key) || 0;
      if (remaining > 0) {
        nextCounts.set(key, remaining - 1);
        return;
      }
      const existing = removed.get(key);
      if (existing) {
        existing.count += 1;
      } else {
        removed.set(key, { count: 1, item });
      }
    });
    return removed;
  }

  function formatAbilityText(ability) {
    const baseName = ability && ability.n ? ability.n : t('game.ability.unnamed');
    const detail = ability && ability.x ? ` (${ability.x})` : '';
    return `${baseName}${detail}`;
  }

  function formatInventoryText(item) {
    return item || t('game.inventory.unnamed');
  }

  function formatConditionText(condition) {
    return condition || t('game.condition.unnamed');
  }

  function populateList(listEl, items, renderItem, emptyMessage, options = {}) {
    if (!listEl) return;
    listEl.innerHTML = "";
    const entries = Array.isArray(items) ? items : [];
    const extraEntries = Array.isArray(options.extraEntries) ? options.extraEntries : [];
    if (!entries.length && !extraEntries.length) {
      const empty = document.createElement("li");
      empty.className = "list-note";
      empty.textContent = emptyMessage;
      listEl.appendChild(empty);
      return;
    }
    const keyFor = typeof options.keyFor === 'function' ? options.keyFor : null;
    const consumeHighlight = typeof options.consumeHighlight === 'function' ? options.consumeHighlight : null;
    const highlightClass = options.highlightClass || 'list-added';
    entries.forEach((entry) => {
      const li = document.createElement("li");
      renderItem(li, entry);
      if (keyFor && consumeHighlight) {
        const key = keyFor(entry);
        if (consumeHighlight(key)) {
          li.classList.add(highlightClass);
        }
      }
      listEl.appendChild(li);
    });
    if (extraEntries.length && typeof options.renderExtraEntry === 'function') {
      extraEntries.forEach((entry) => {
        const li = document.createElement("li");
        options.renderExtraEntry(li, entry);
        listEl.appendChild(li);
      });
    }
  }

  function renderAbilityList(listEl, abilities, addedCounts = null, removedEntries = null) {
    const consumeHighlight = createHighlightConsumer(addedCounts);
    const extras = Array.isArray(removedEntries) ? removedEntries : [];
    populateList(
      listEl,
      abilities,
      (li, ability) => {
        li.textContent = formatAbilityText(ability);
      },
      t('game.noAbility'),
      {
        keyFor: abilityKey,
        consumeHighlight,
        extraEntries: extras,
        renderExtraEntry: (li, entry) => {
          const ability = entry ? entry.item : null;
          const baseText = formatAbilityText(ability);
          const count = entry && Number.isFinite(entry.count) ? entry.count : 1;
          li.textContent = count > 1 ? `${baseText} x${count}` : baseText;
          li.classList.add('list-removed');
        },
      }
    );
  }

  function renderInventoryList(listEl, items, addedCounts = null, removedEntries = null) {
    const consumeHighlight = createHighlightConsumer(addedCounts);
    const extras = Array.isArray(removedEntries) ? removedEntries : [];
    populateList(
      listEl,
      items,
      (li, item) => {
        li.textContent = formatInventoryText(item);
      },
      t('game.noInventory'),
      {
        keyFor: textEntryKey,
        consumeHighlight,
        extraEntries: extras,
        renderExtraEntry: (li, entry) => {
          const value = entry ? entry.item : null;
          const baseText = formatInventoryText(value);
          const count = entry && Number.isFinite(entry.count) ? entry.count : 1;
          li.textContent = count > 1 ? `${baseText} x${count}` : baseText;
          li.classList.add('list-removed');
        },
      }
    );
  }

  function renderConditionList(listEl, conditions, addedCounts = null, removedEntries = null) {
    const consumeHighlight = createHighlightConsumer(addedCounts);
    const extras = Array.isArray(removedEntries) ? removedEntries : [];
    populateList(
      listEl,
      conditions,
      (li, condition) => {
        li.textContent = formatConditionText(condition);
      },
      t('game.noCondition'),
      {
        keyFor: textEntryKey,
        consumeHighlight,
        extraEntries: extras,
        renderExtraEntry: (li, entry) => {
          const value = entry ? entry.item : null;
          const baseText = formatConditionText(value);
          const count = entry && Number.isFinite(entry.count) ? entry.count : 1;
          li.textContent = count > 1 ? `${baseText} x${count}` : baseText;
          li.classList.add('list-removed');
        },
      }
    );
  }

  function clearPrivatePanels() {
    const youFlags = $("youFlags");
    const youAbilities = $("youAbilities");
    const youInv = $("youInv");
    const youCond = $("youCond");
    if (youFlags) {
      youFlags.innerHTML = "";
      youFlags.style.display = "none";
    }
    renderAbilityList(youAbilities, []);
    renderInventoryList(youInv, []);
    renderConditionList(youCond, []);
    state.lastPrivate = null;
    if (state.youHighlights && typeof state.youHighlights === 'object') {
      state.youHighlights.abilities = resetHighlightBucket(state.youHighlights.abilities);
      state.youHighlights.inventory = resetHighlightBucket(state.youHighlights.inventory);
      state.youHighlights.conditions = resetHighlightBucket(state.youHighlights.conditions);
      state.youHighlights.turn = Number.isFinite(state.currentTurn) ? state.currentTurn : 0;
    }
    if (state.youRemovals && typeof state.youRemovals === 'object') {
      state.youRemovals.abilities = resetHighlightBucket(state.youRemovals.abilities);
      state.youRemovals.inventory = resetHighlightBucket(state.youRemovals.inventory);
      state.youRemovals.conditions = resetHighlightBucket(state.youRemovals.conditions);
      state.youRemovals.turn = Number.isFinite(state.currentTurn) ? state.currentTurn : 0;
    }
  }

  function expireSession(message, options = {}) {
    const stored = getStoredPlayer();
    const fallbackName = stored && typeof stored.name === 'string' ? stored.name : ($("name") ? $("name").value : '');
    const fallbackBackground = stored && typeof stored.background === 'string' ? stored.background : ($("background") ? $("background").value : '');
    rememberJoinInputs(fallbackName, fallbackBackground, true);
    applyStoredJoinInputs({ name: fallbackName, background: fallbackBackground });
    state.playerId = null;
    state.playerToken = null;
    state.playerName = fallbackName || '';
    state.playerBackground = fallbackBackground || '';
    state.pendingJoin = null;
    syncNarrationToggle(state.autoTtsEnabled);
    showJoinView();
    clearPrivatePanels();
    if (ws && ws.readyState <= WebSocket.OPEN) {
      try { ws.close(); } catch (err) { /* ignore */ }
    }
    setJoinWaiting(false);
    const key = options.key;
    const args = options.args;
    if (key) {
      updateJoinStatus('', { key, args });
      alert(t(key, args));
    } else if (message) {
      updateJoinStatus(message);
      alert(message);
    } else {
      updateJoinStatus('');
    }
  }

  function isAuthFailure(status) {
    return status === 403 || status === 404;
  }

  async function handleActionError(resp, contextKey) {
    if (isAuthFailure(resp.status)) {
      expireSession('', { key: 'join.status.invalidSession' });
      return;
    }
    let detail = '';
    try {
      detail = await resp.text();
    } catch (err) {
      detail = '';
    }
    const base = (typeof contextKey === 'string' && TRANSLATIONS[contextKey]) ? t(contextKey) : (contextKey || '');
    const suffix = detail ? `: ${detail}` : '';
    alert(`${base}${suffix}`);
  }

  let portraitPreviewEl = null;
  let portraitPreviewImg = null;
  let portraitPreviewSheetWrapper = null;
  let portraitPreviewSheetImg = null;
  let portraitPreviewFrame = null;
  const portraitPreviewState = {
    clientX: null,
    clientY: null,
    fallbackEl: null,
  };

  function ensurePortraitPreview() {
    if (!portraitPreviewEl) {
      portraitPreviewEl = document.createElement("div");
      portraitPreviewEl.className = "portrait-preview";
      const primaryWrapper = document.createElement("div");
      primaryWrapper.className = "portrait-preview-primary";
      portraitPreviewImg = document.createElement("img");
      portraitPreviewImg.alt = t('game.portrait.previewAlt');
      primaryWrapper.appendChild(portraitPreviewImg);
      portraitPreviewEl.appendChild(primaryWrapper);

      portraitPreviewSheetWrapper = document.createElement("div");
      portraitPreviewSheetWrapper.className = "portrait-preview-turnaround";
      portraitPreviewSheetWrapper.style.display = "none";
      portraitPreviewSheetImg = document.createElement("img");
      portraitPreviewSheetImg.alt = t('game.portrait.turnaroundAlt');
      portraitPreviewSheetWrapper.appendChild(portraitPreviewSheetImg);
      portraitPreviewEl.appendChild(portraitPreviewSheetWrapper);
      document.body.appendChild(portraitPreviewEl);
    }
    return portraitPreviewEl;
  }

  function hidePortraitPreview() {
    if (portraitPreviewFrame !== null) {
      cancelAnimationFrame(portraitPreviewFrame);
      portraitPreviewFrame = null;
    }
    if (portraitPreviewEl) {
      portraitPreviewEl.style.display = "none";
    }
  }

  function updatePortraitPreviewPosition(evt, fallbackEl) {
    if (evt && typeof evt.clientX === "number" && typeof evt.clientY === "number") {
      portraitPreviewState.clientX = evt.clientX;
      portraitPreviewState.clientY = evt.clientY;
    } else {
      portraitPreviewState.clientX = null;
      portraitPreviewState.clientY = null;
    }
    if (fallbackEl) {
      portraitPreviewState.fallbackEl = fallbackEl;
    }
    if (!portraitPreviewEl || portraitPreviewEl.style.display === "none") {
      return;
    }
    if (portraitPreviewFrame === null) {
      portraitPreviewFrame = requestAnimationFrame(flushPortraitPreviewPosition);
    }
  }

  function flushPortraitPreviewPosition() {
    portraitPreviewFrame = null;
    if (!portraitPreviewEl || portraitPreviewEl.style.display === "none") {
      return;
    }
    const padding = 16;
    const offset = 18;
    let clientX = portraitPreviewState.clientX;
    let clientY = portraitPreviewState.clientY;
    const fallbackEl = portraitPreviewState.fallbackEl;
    if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
      if (fallbackEl) {
        const rect = fallbackEl.getBoundingClientRect();
        clientX = rect.right;
        clientY = rect.top + rect.height / 2;
      } else {
        clientX = window.innerWidth / 2;
        clientY = window.innerHeight / 2;
      }
    }
    const box = portraitPreviewEl.getBoundingClientRect();
    let left = clientX + offset;
    let top = clientY + offset;
    const maxLeft = window.innerWidth - box.width - padding;
    const maxTop = window.innerHeight - box.height - padding;
    if (left > maxLeft) {
      left = Math.max(padding, clientX - box.width - offset);
    }
    if (top > maxTop) {
      top = Math.max(padding, clientY - box.height - offset);
    }
    portraitPreviewEl.style.left = `${Math.max(padding, left)}px`;
    portraitPreviewEl.style.top = `${Math.max(padding, top)}px`;
  }

  function showPortraitPreview(preview, evt, fallbackEl) {
    if (!preview || !preview.src) return;
    const el = ensurePortraitPreview();
    if (!portraitPreviewImg) return;
    portraitPreviewImg.src = preview.src;
    const altText = preview.prompt
      ? t('game.portrait.previewWithPrompt', { prompt: preview.prompt })
      : t('game.portrait.previewAlt');
    portraitPreviewImg.alt = altText;

    if (portraitPreviewSheetWrapper && portraitPreviewSheetImg) {
      const hasTurnaround = Boolean(preview.turnaroundSrc);
      if (hasTurnaround) {
        portraitPreviewSheetWrapper.style.display = "block";
        portraitPreviewSheetImg.src = preview.turnaroundSrc;
        const turnaroundAlt = preview.turnaroundPrompt
          ? t('game.portrait.turnaroundWithPrompt', { prompt: preview.turnaroundPrompt })
          : t('game.portrait.turnaroundAlt');
        portraitPreviewSheetImg.alt = turnaroundAlt;
      } else {
        portraitPreviewSheetWrapper.style.display = "none";
        portraitPreviewSheetImg.src = "";
        portraitPreviewSheetImg.alt = "";
      }
    }

    el.style.display = "block";
    updatePortraitPreviewPosition(evt, fallbackEl);
  }

  function updatePortraitButtonState(btn, lockActive) {
    if (!btn) return;
    const owned = btn.dataset.owned === "true";
    const pending = btn.dataset.pending === "true";
    const hasImage = btn.dataset.hasImage === "true";
    const canClick = Boolean(owned && state.playerToken && !pending && !lockActive);
    btn.dataset.clickable = canClick ? "true" : "false";
    if (canClick) {
      btn.onclick = () => requestPortrait(btn);
    } else {
      btn.onclick = null;
    }
    if (owned) {
      if (lockActive && !pending) {
        btn.title = t('game.portrait.tooltip.lockedBusy');
      } else if (pending) {
        btn.title = t('game.portrait.tooltip.lockedPreJoin');
      } else if (hasImage) {
        btn.title = t('game.portrait.tooltip.refresh');
      } else {
        btn.title = t('game.portrait.tooltip.generate');
      }
    } else if (hasImage) {
      btn.title = t('game.portrait.tooltip.hover');
    } else {
      btn.title = t('game.portrait.tooltip.onlyOwner');
    }
  }

  // UI helpers
  function setLockBanner(lock) {
    const banner = $("lockBanner");
    const buttons = [$("btnSubmit"), $("btnNextTurn"), $("btnCreateImage"), $("btnAnimateImage"), $("btnAnimateScene"), $("btnEnter")].filter(Boolean);
    const portraitButtons = Array.from(document.querySelectorAll(".player-portrait"));
    state.lock = lock || {active:false, reason:""};
    const active = Boolean(state.lock.active);
    if (banner) {
      if (active) {
        let why = t('game.lock.banner.busy');
        if (state.lock.reason === "resolving_turn") why = t('game.lock.banner.resolving');
        else if (state.lock.reason === "generating_image") why = t('game.lock.banner.generatingImage');
        else if (state.lock.reason === "generating_portrait") why = t('game.lock.banner.generatingPortrait');
        else if (state.lock.reason === "generating_video") why = t('game.lock.banner.generatingVideo');
        const hasCountdown = ensureLockBannerCountdown(banner, state.lock.reason);
        if (!hasCountdown) {
          banner.textContent = why;
        }
      } else {
        stopLockBannerCountdown();
        banner.textContent = "";
      }
    } else {
      stopLockBannerCountdown();
    }
    const titleMap = {
      resolving_turn: t('game.lock.reason.resolving'),
      generating_image: t('game.lock.reason.generatingImage'),
      generating_portrait: t('game.lock.reason.generatingPortrait'),
      generating_video: t('game.lock.reason.generatingVideo'),
    };
    const disableTitle = titleMap[state.lock.reason] || t('game.lock.reason.busy');
    buttons.forEach((b) => {
      if (!b) return;
      if (active) {
        b.setAttribute('disabled', 'true');
        b.title = disableTitle;
      } else if (b.id === "btnEnter" && state.pendingJoin) {
        b.setAttribute('disabled', 'true');
        b.title = t('join.status.requestSent');
      } else {
        b.removeAttribute('disabled');
        b.title = "";
      }
    });
    if (active) {
      hidePortraitPreview();
    }
    portraitButtons.forEach((btn) => updatePortraitButtonState(btn, active));
  }

  function toggleCustomWorldInput(isCustom, options = {}) {
    const input = $("setWorldCustom");
    if (!input) return;
    const shouldShow = Boolean(isCustom);
    if (shouldShow) {
      input.classList.remove('hidden');
      input.removeAttribute('disabled');
      if (options.focus) {
        input.focus();
        input.select();
      }
    } else {
      input.classList.add('hidden');
      input.setAttribute('disabled', 'true');
    }
  }

  function escapeCssValue(value) {
    const text = typeof value === 'string' ? value : '';
    if (window.CSS && typeof window.CSS.escape === 'function') {
      return CSS.escape(text);
    }
    return text.replace(/["\\]/g, '\\$&');
  }

  function createWorldStyleButton(entry, depth) {
    const button = document.createElement('button');
    button.type = 'button';
    const depthClass = `level-${Math.min(Math.max(depth, 0), 3)}`;
    button.className = `world-style-option ${depthClass}`.trim();
    const value = entry && typeof entry.value === 'string' ? entry.value : '';
    const normalizedValue = normalizeWorldStyleValue(value);
    button.dataset.value = value;
    button.dataset.nodeKey = normalizedValue;
    button.setAttribute('role', 'option');
    if (Array.isArray(entry?.children) && entry.children.length) {
      button.dataset.hasChildren = 'true';
      button.setAttribute('aria-haspopup', 'true');
      button.setAttribute('aria-expanded', 'false');
    }
    const labelSpan = document.createElement('span');
    if (normalizedValue === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) {
      const customLabel = t('settings.worldStyle.option.custom') || (entry && typeof entry.name === 'string' ? entry.name : value);
      labelSpan.textContent = customLabel;
    } else {
      labelSpan.textContent = entry && typeof entry.name === 'string' ? entry.name : value;
    }
    button.appendChild(labelSpan);
    if (entry && entry.appliesTo && WORLD_STYLE_APPLIES_HINTS[entry.appliesTo]) {
      const hintSpan = document.createElement('span');
      hintSpan.className = 'world-style-hint';
      hintSpan.textContent = WORLD_STYLE_APPLIES_HINTS[entry.appliesTo];
      button.appendChild(hintSpan);
    }
    button.addEventListener('click', (event) => {
      event.preventDefault();
      const isCustom = normalizedValue === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE);
      selectWorldStyle(value, { fromMenu: true, focusCustom: isCustom });
      closeWorldStyleMenu({ silentFocus: isCustom });
    });
    return button;
  }

  function createWorldStyleNode(entry, depth = 0) {
    const hasChildren = Array.isArray(entry?.children) && entry.children.length;
    const normalizedKey = normalizeWorldStyleValue(entry && entry.value ? entry.value : '');
    if (!hasChildren) {
      return createWorldStyleButton(entry, depth);
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'world-style-group';

    const header = document.createElement('div');
    header.className = `world-style-group-header level-${Math.min(Math.max(depth, 0), 3)}`;

    const expander = document.createElement('button');
    expander.type = 'button';
    expander.className = 'world-style-expander';
    expander.dataset.nodeKey = normalizedKey;
    expander.setAttribute('aria-label', `Toggle ${entry?.name || entry?.value || 'category'}`);
    expander.setAttribute('aria-expanded', 'false');
    expander.textContent = '▸';

    const optionButton = createWorldStyleButton(entry, depth);
    optionButton.classList.add('world-style-group-button');

    expander.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      const expanded = expander.getAttribute('aria-expanded') === 'true';
      setWorldStyleGroupExpandedByKey(normalizedKey, !expanded);
    });

    header.appendChild(expander);
    header.appendChild(optionButton);

    const childContainer = document.createElement('div');
    childContainer.className = 'world-style-children hidden';
    childContainer.dataset.parentKey = normalizedKey;
    childContainer.setAttribute('role', 'group');

    entry.children.forEach((child) => {
      childContainer.appendChild(createWorldStyleNode(child, depth + 1));
    });

    wrapper.appendChild(header);
    wrapper.appendChild(childContainer);
    return wrapper;
  }

  function renderWorldStyleMenu(menu) {
    if (!menu) return;
    menu.innerHTML = '';
    const fragment = document.createDocumentFragment();
    WORLD_STYLE_ENTRIES.forEach((entry) => {
      fragment.appendChild(createWorldStyleNode(entry, 0));
    });
    fragment.appendChild(createWorldStyleNode(WORLD_STYLE_CUSTOM_ENTRY, 0));
    menu.appendChild(fragment);
  }

  function setWorldStyleGroupExpandedByKey(key, expanded) {
    if (!key) return;
    const menu = $('worldStyleMenu');
    if (!menu) return;
    const escaped = escapeCssValue(key);
    const container = menu.querySelector(`.world-style-children[data-parent-key="${escaped}"]`);
    const expander = menu.querySelector(`.world-style-expander[data-node-key="${escaped}"]`);
    const labelButton = menu.querySelector(`.world-style-option[data-node-key="${escaped}"]`);
    if (container) {
      container.classList.toggle('hidden', !expanded);
    }
    if (expander) {
      expander.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      expander.textContent = expanded ? '▾' : '▸';
    }
    if (labelButton) {
      labelButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      if (expanded) {
        labelButton.dataset.expanded = 'true';
      } else {
        labelButton.removeAttribute('data-expanded');
      }
    }
  }

  function isWorldStyleGroupExpanded(key) {
    if (!key) return false;
    const menu = $('worldStyleMenu');
    if (!menu) return false;
    const escaped = escapeCssValue(key);
    const container = menu.querySelector(`.world-style-children[data-parent-key="${escaped}"]`);
    return container ? !container.classList.contains('hidden') : false;
  }

  function expandWorldStyleAncestors(normalizedValue) {
    if (!normalizedValue) return;
    const visited = new Set();
    let current = normalizedValue;
    while (WORLD_STYLE_PARENT_MAP.has(current)) {
      const parentKey = WORLD_STYLE_PARENT_MAP.get(current);
      if (!parentKey || visited.has(parentKey)) break;
      setWorldStyleGroupExpandedByKey(parentKey, true);
      visited.add(parentKey);
      current = parentKey;
    }
  }

  function isWorldStyleElementHidden(element, root) {
    if (!element) return true;
    let node = element;
    while (node && node !== root) {
      if (node.classList && node.classList.contains('hidden')) {
        return true;
      }
      node = node.parentElement;
    }
    return false;
  }

  function getVisibleWorldStyleButtons(menu) {
    if (!menu) return [];
    const options = Array.from(menu.querySelectorAll('.world-style-option'));
    return options.filter((option) => !isWorldStyleElementHidden(option, menu));
  }

  function focusWorldStyleParent(button) {
    const menu = $('worldStyleMenu');
    if (!menu || !button || !button.dataset) return false;
    const key = button.dataset.nodeKey;
    const parentKey = key ? WORLD_STYLE_PARENT_MAP.get(key) : null;
    if (!parentKey) return false;
    const parentButton = menu.querySelector(`.world-style-option[data-node-key="${escapeCssValue(parentKey)}"]`);
    if (parentButton) {
      parentButton.focus();
      return true;
    }
    return false;
  }

  function focusFirstChildOfGroup(key) {
    const menu = $('worldStyleMenu');
    if (!menu || !key) return false;
    const escaped = escapeCssValue(key);
    const container = menu.querySelector(`.world-style-children[data-parent-key="${escaped}"]`);
    if (!container) return false;
    const childOption = Array.from(container.querySelectorAll('.world-style-option')).find((btn) => !isWorldStyleElementHidden(btn, menu));
    if (childOption) {
      childOption.focus();
      return true;
    }
    return false;
  }

  function updateWorldMenuSelection(value) {
    const menu = $('worldStyleMenu');
    if (!menu) return;
    const normalized = normalizeWorldStyleValue(value);
    expandWorldStyleAncestors(normalized);
    const options = menu.querySelectorAll('.world-style-option');
    options.forEach((option) => {
      const optionValue = option && option.dataset ? option.dataset.value || '' : '';
      const isMatch = normalizeWorldStyleValue(optionValue) === normalized;
      if (isMatch) {
        option.dataset.selected = 'true';
        option.setAttribute('aria-selected', 'true');
        if (option.dataset && option.dataset.hasChildren === 'true') {
          setWorldStyleGroupExpandedByKey(option.dataset.nodeKey, true);
        }
        if (typeof option.scrollIntoView === 'function' && !menu.classList.contains('hidden')) {
          option.scrollIntoView({ block: 'nearest' });
        }
      } else {
        option.removeAttribute('data-selected');
        option.setAttribute('aria-selected', 'false');
      }
    });
  }

  function currentWorldStyleLabel(value) {
    const normalized = normalizeWorldStyleValue(value);
    if (normalized === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) {
      const customLabel = t('settings.worldStyle.option.custom') || 'Custom…';
      const customInput = $('setWorldCustom');
      const customValue = customInput ? customInput.value.trim() : '';
      return customValue ? `${customLabel}: ${customValue}` : customLabel;
    }
    const entry = findWorldStyleEntry(value) || findWorldStyleEntry(DEFAULT_WORLD_STYLE) || WORLD_STYLE_ENTRIES[0] || null;
    if (entry && typeof entry.name === 'string' && entry.name) {
      return entry.name;
    }
    return value || DEFAULT_WORLD_STYLE;
  }

  function updateWorldPickerDisplay(value) {
    const toggle = $('worldStyleToggle');
    if (!toggle) return;
    const label = currentWorldStyleLabel(value);
    toggle.textContent = label;
    toggle.setAttribute('data-current-value', value || '');
    const entry = findWorldStyleEntry(value);
    if (entry && entry.appliesTo && WORLD_STYLE_APPLIES_HINTS[entry.appliesTo]) {
      toggle.title = `${label} - ${WORLD_STYLE_APPLIES_HINTS[entry.appliesTo]}`;
    } else {
      toggle.title = label;
    }
  }

  function selectWorldStyle(value, options = {}) {
    const input = $('setWorld');
    if (!input) return '';
    const normalized = normalizeWorldStyleValue(value);
    let finalValue = value;
    if (normalized === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) {
      finalValue = CUSTOM_WORLD_VALUE;
    } else {
      const entry = findWorldStyleEntry(value);
      if (entry) {
        finalValue = entry.value;
      } else {
        finalValue = '';
      }
    }
    if (!finalValue) {
      const fallbackEntry = findWorldStyleEntry(DEFAULT_WORLD_STYLE) || WORLD_STYLE_ENTRIES[0] || WORLD_STYLE_CUSTOM_ENTRY;
      finalValue = fallbackEntry ? fallbackEntry.value : DEFAULT_WORLD_STYLE;
    }
    const previous = input.value;
    input.value = finalValue;
    const isCustom = normalizeWorldStyleValue(finalValue) === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE);
    toggleCustomWorldInput(isCustom, { focus: !!options.focusCustom });
    updateWorldPickerDisplay(finalValue);
    updateWorldMenuSelection(finalValue);
    if (!options.silent && previous !== finalValue) {
      input.dispatchEvent(new Event('change', { bubbles: true }));
    }
    return finalValue;
  }

  function closeWorldStyleMenu(options = {}) {
    const menu = $('worldStyleMenu');
    const toggle = $('worldStyleToggle');
    if (!menu || !toggle) return;
    if (menu.classList.contains('hidden')) return;
    menu.classList.add('hidden');
    toggle.setAttribute('aria-expanded', 'false');
    if (!options.silentFocus) {
      toggle.focus({ preventScroll: true });
    }
  }

  function openWorldStyleMenu() {
    const menu = $('worldStyleMenu');
    const toggle = $('worldStyleToggle');
    const input = $('setWorld');
    if (!menu || !toggle) return;
    menu.classList.remove('hidden');
    toggle.setAttribute('aria-expanded', 'true');
    const currentValue = input ? input.value : DEFAULT_WORLD_STYLE;
    updateWorldMenuSelection(currentValue);
    const visibleOptions = getVisibleWorldStyleButtons(menu);
    let target = visibleOptions.find((option) => option.dataset && option.dataset.selected === 'true');
    if (!target) {
      target = visibleOptions[0];
    }
    if (target) {
      target.focus({ preventScroll: false });
    }
  }

  function handleWorldStyleOutsideEvent(event) {
    const menu = $('worldStyleMenu');
    const toggle = $('worldStyleToggle');
    if (!menu || menu.classList.contains('hidden')) return;
    const target = event?.target;
    if (toggle && target && toggle.contains(target)) return;
    if (menu && target && menu.contains(target)) return;
    closeWorldStyleMenu({ silentFocus: true });
  }

  function handleWorldStyleMenuKeydown(event) {
    const menu = $('worldStyleMenu');
    if (!menu || menu.classList.contains('hidden')) return;
    const options = getVisibleWorldStyleButtons(menu);
    if (!options.length) return;
    let active = document.activeElement;
    if (active && active.classList.contains('world-style-expander')) {
      const key = active.dataset ? active.dataset.nodeKey : null;
      const labelButton = key ? menu.querySelector(`.world-style-option[data-node-key="${escapeCssValue(key)}"]`) : null;
      if (labelButton) {
        labelButton.focus();
        active = labelButton;
      }
    }
    if (!active || !active.classList || !active.classList.contains('world-style-option')) {
      active = options[0];
      if (active) active.focus();
    }
    const currentIndex = options.indexOf(active);
    if (event.key === 'Escape') {
      event.preventDefault();
      closeWorldStyleMenu();
      return;
    }
    if (event.key === 'ArrowDown') {
      event.preventDefault();
      const next = options[Math.min((currentIndex >= 0 ? currentIndex + 1 : 0), options.length - 1)] || options[options.length - 1];
      if (next) next.focus();
      return;
    }
    if (event.key === 'ArrowUp') {
      event.preventDefault();
      const prev = options[Math.max((currentIndex >= 0 ? currentIndex - 1 : options.length - 1), 0)] || options[0];
      if (prev) prev.focus();
      return;
    }
    if (event.key === 'Home') {
      event.preventDefault();
      options[0]?.focus();
      return;
    }
    if (event.key === 'End') {
      event.preventDefault();
      options[options.length - 1]?.focus();
      return;
    }
    if (event.key === 'ArrowRight') {
      if (active && active.dataset && active.dataset.hasChildren === 'true') {
        const key = active.dataset.nodeKey;
        if (!isWorldStyleGroupExpanded(key)) {
          event.preventDefault();
          setWorldStyleGroupExpandedByKey(key, true);
        } else if (focusFirstChildOfGroup(key)) {
          event.preventDefault();
        }
      }
      return;
    }
    if (event.key === 'ArrowLeft') {
      if (active && active.dataset) {
        const key = active.dataset.nodeKey;
        if (active.dataset.hasChildren === 'true' && isWorldStyleGroupExpanded(key)) {
          event.preventDefault();
          setWorldStyleGroupExpandedByKey(key, false);
          return;
        }
        if (focusWorldStyleParent(active)) {
          event.preventDefault();
          return;
        }
      }
      return;
    }
    if (event.key === 'Enter' || event.key === ' ') {
      if (active && active.classList.contains('world-style-option')) {
        event.preventDefault();
        active.click();
      }
      return;
    }
    if (event.key === 'Tab') {
      closeWorldStyleMenu({ silentFocus: true });
    }
  }

  async function initializeWorldStylePicker() {
    if (worldStyleMenuInitialized) return;
    const toggle = $('worldStyleToggle');
    const menu = $('worldStyleMenu');
    const input = $('setWorld');
    if (!toggle || !menu || !input) return;
    await ensureWorldStylesInitialized();
    worldStyleMenuInitialized = true;
    renderWorldStyleMenu(menu);
    toggle.setAttribute('aria-expanded', 'false');
    toggle.addEventListener('click', (event) => {
      event.preventDefault();
      const expanded = toggle.getAttribute('aria-expanded') === 'true';
      if (expanded) {
        closeWorldStyleMenu();
      } else {
        openWorldStyleMenu();
      }
    });
    menu.addEventListener('keydown', handleWorldStyleMenuKeydown);
    document.addEventListener('mousedown', handleWorldStyleOutsideEvent);
    document.addEventListener('focusin', handleWorldStyleOutsideEvent);
    const initial = input.value || DEFAULT_WORLD_STYLE;
    selectWorldStyle(initial, { silent: true });
  }

  function pillClass(word) {
    if (!word) return "pill";
    if (["healthy","sturdy","fit","fine"].includes(word)) return "pill good";
    if (["wounded","soaked","tired","cursed","hungry","exhausted"].includes(word)) return "pill warn";
    if (["dead","poisoned","broken"].includes(word)) return "pill bad";
    return "pill";
    }

  // Populate settings modal
  async function openSettings() {
    startButtonCountdown('btnSettings', (seconds) => t('header.settingsCountdown', { seconds }));
    try {
      await ensureWorldStylesInitialized();
      const s = await (await fetch("/api/settings")).json();
      const worldSelect = $("setWorld");
      const customWorldInput = $("setWorldCustom");
      if (worldSelect) {
        const rawWorldStyle = typeof s.world_style === 'string' ? s.world_style.trim() : '';
        const normalizedRaw = normalizeWorldStyleValue(rawWorldStyle);
        if (normalizedRaw === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) {
          if (customWorldInput) {
            customWorldInput.value = '';
          }
          selectWorldStyle(CUSTOM_WORLD_VALUE, { silent: true });
        } else if (rawWorldStyle && !worldStyleExists(rawWorldStyle)) {
          if (customWorldInput) {
            customWorldInput.value = rawWorldStyle;
          }
          selectWorldStyle(CUSTOM_WORLD_VALUE, { silent: true });
        } else {
          if (customWorldInput) {
            customWorldInput.value = '';
          }
          const valueToApply = rawWorldStyle || DEFAULT_WORLD_STYLE;
          selectWorldStyle(valueToApply, { silent: true });
        }
      }
      $("setDiff").value = s.difficulty || "Normal";
      $("setThinking").value = (s.thinking_mode || "none");
      const historyToggle = $("setHistorySummary");
      if (historyToggle) {
        historyToggle.checked = String(s.history_mode || 'full').toLowerCase() === 'summary';
      }
      const fxSaverToggle = $("setFxSaver");
      if (fxSaverToggle) {
        fxSaverToggle.checked = !!state.fxSaverEnabled;
      }
      // Fetch models first, then set selection
      const textSel = $("setTextModel");
      const imgSel = $("setImageModel");
      const videoSel = $("setVideoModel");
      const narrationSel = $("setNarrationModel");
      const videoLengthInput = $("setVideoLength");
      const storedVideoLength = clampVideoLength(
        s.video_duration_seconds ?? state.videoLengthSeconds ?? DEFAULT_VIDEO_LENGTH_SECONDS
      );
      setVideoLengthValue(storedVideoLength, { silent: true });
      state.videoLengthSeconds = storedVideoLength;
      try {
        const resp = await fetch("/api/models");
        if (!resp.ok) throw new Error("model list request failed");
        const models = await resp.json();
        const availableModels = models.models || [];
        const narrationModels = Array.isArray(models.narration_models) ? models.narration_models : [];

        textSel.innerHTML = "";
        const seenTextModels = new Set();
        const textOptions = [];
        availableModels.forEach(m => {
          const provider = String(m.provider || 'gemini').toLowerCase();
          const supported = Array.isArray(m.supported) ? m.supported.map(x => String(x).toLowerCase()) : [];
          let supportsText = false;
          if (provider === 'grok') {
            supportsText = supported.some(x => x.includes('chat'));
          } else if (provider === 'openai') {
            supportsText = supported.some(x => x.includes('response') || x.includes('chat') || x.includes('completion'));
            if (!supportsText && !supported.length) supportsText = true;
          } else {
            supportsText = supported.includes('generatecontent') || supported.includes('responses');
          }
          if (!supportsText) return;
          let rawName = String(m.name || '').trim();
          if (!rawName) return;
          if (provider === 'gemini') {
            rawName = rawName.replace(/^models\//, '');
            if (!rawName.toLowerCase().startsWith('gemini-2.5')) {
              return;
            }
            if (!rawName) return;
          } else if (provider === 'openai') {
            rawName = rawName.replace(/^openai[\/:]/, '');
            if (!rawName.toLowerCase().startsWith('gpt-5')) {
              return;
            }
            if (!rawName) return;
          } else if (provider === 'grok') {
            if (!rawName.toLowerCase().startsWith('grok-4')) {
              return;
            }
          }
          if (seenTextModels.has(rawName)) return;
          seenTextModels.add(rawName);
          const label = String(m.displayName || m.name || rawName);
          const suffix = provider === 'grok' ? ' · Grok' : provider === 'gemini' ? ' · Gemini' : provider === 'openai' ? ' · OpenAI' : '';
          textOptions.push({
            value: rawName,
            provider,
            display: `${label}${suffix}`,
          });
        });
        textOptions.sort((a, b) => a.display.localeCompare(b.display, undefined, { sensitivity: 'base' }));
        textOptions.forEach(entry => {
          const opt = document.createElement('option');
          opt.value = entry.value;
          opt.dataset.provider = entry.provider;
          opt.textContent = entry.display;
          textSel.appendChild(opt);
        });
        const desiredTextModel = (s.text_model || DEFAULT_TEXT_MODEL || '').trim();
        if (desiredTextModel) {
          const optionAvailable = [...textSel.options].some((opt) => opt.value === desiredTextModel);
          if (optionAvailable) {
            textSel.value = desiredTextModel;
          } else if (textSel.options.length) {
            textSel.selectedIndex = 0;
          }
        } else if (textSel.options.length) {
          textSel.selectedIndex = 0;
        }

        imgSel.innerHTML = "";
        // From live list, prefer the official image-preview model
        availableModels.forEach(m => {
          const provider = String(m.provider || 'gemini').toLowerCase();
          if (provider !== 'gemini') return;
          const nm = m.name.replace(/^models\//,"");
          if (nm.includes("flash-image")) {
            const opt = document.createElement("option");
            opt.value = nm;
            opt.textContent = m.displayName || nm;
            imgSel.appendChild(opt);
          }
        });
        // Fallback UI case: if not present in the account/region, show none (per requirement: no fallback hardcoding)
        if (s.image_model) {
          const exists = [...imgSel.options].some(o => o.value === s.image_model);
          if (exists) imgSel.value = s.image_model;
        }

        if (videoSel) {
          videoSel.innerHTML = "";
          const seenVideoModels = new Set();
          const videoOptions = [];
          availableModels.forEach(m => {
            const provider = String(m.provider || 'gemini').toLowerCase();
            if (provider !== 'gemini') return;
            const category = typeof m.category === 'string' ? m.category.toLowerCase() : '';
            const supportedRaw = Array.isArray(m.supported) ? m.supported : [];
            const supported = supportedRaw.map((value) => String(value).toLowerCase());

            let rawName = '';
            if (typeof m.modelId === 'string' && m.modelId.trim()) {
              rawName = m.modelId.trim();
            } else if (typeof m.name === 'string' && m.name.trim()) {
              rawName = m.name.trim().replace(/^models\//, '');
            }
            if (!rawName) return;

            const isVeoName = rawName.toLowerCase().startsWith('veo');
            const isVideo = category === 'video' || isVeoName || supported.includes('predictlongrunning');
            if (!isVideo) return;
            if (seenVideoModels.has(rawName)) return;

            seenVideoModels.add(rawName);
            const baseLabel = typeof m.displayName === 'string' && m.displayName.trim()
              ? m.displayName.trim()
              : rawName;
            videoOptions.push({ value: rawName, label: rawName, helper: baseLabel });
          });

          if (!videoOptions.some(entry => entry.value.toLowerCase() === 'framepack')) {
            videoOptions.push({ value: 'FramePack', label: 'FramePack', helper: 'FramePack' });
          }

          if (!videoOptions.some(entry => entry.value.toLowerCase() === 'static framepack')) {
            videoOptions.push({
              value: 'Static FramePack',
              label: 'Static FramePack',
              helper: 'Reuse the generated still image for a subtle FramePack drift',
            });
          }

          if (!videoOptions.some(entry => entry.value.toLowerCase() === 'parallax')) {
            videoOptions.push({
              value: 'Parallax',
              label: 'Parallax',
              helper: 'Animate an existing image with a parallax camera move',
            });
          }

          videoOptions.sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base' }));
          videoOptions.forEach(entry => {
            const opt = document.createElement('option');
            opt.value = entry.value;
            opt.textContent = entry.label;
            if (entry.helper && entry.helper !== entry.label) {
              opt.title = entry.helper;
            }
            videoSel.appendChild(opt);
          });

          const desiredVideoModel = (s.video_model || DEFAULT_VIDEO_MODEL || '').trim();
          if (desiredVideoModel) {
            const hasVideoModel = [...videoSel.options].some((opt) => opt.value === desiredVideoModel);
            if (hasVideoModel) {
              videoSel.value = desiredVideoModel;
            } else {
              const opt = document.createElement('option');
              opt.value = desiredVideoModel;
              opt.textContent = `${desiredVideoModel} ${t('settings.videoModel.savedSuffix')}`;
              videoSel.appendChild(opt);
              videoSel.value = desiredVideoModel;
            }
          } else if (videoSel.options.length) {
            videoSel.value = DEFAULT_VIDEO_MODEL;
          }
          const handleVideoModelChange = () => {
            updateVideoLengthDisabledState(videoSel.value);
          };
          updateVideoLengthDisabledState(videoSel.value);
          if (videoSel) {
            videoSel.onchange = handleVideoModelChange;
          }
        }

        if (narrationSel) {
          narrationSel.innerHTML = "";
          narrationSel.removeAttribute("disabled");
          narrationSel.title = "";

          const allowedNarrationModels = narrationModels.filter((model) => modelSupportsLanguage(model, state.language));
          allowedNarrationModels.forEach(m => {
            const value = m.id || m.model_id || m.modelId;
            if (!value) return;
            const opt = document.createElement("option");
            opt.value = value;
            const labelText = m.name || value;
            opt.textContent = labelText;
            narrationSel.appendChild(opt);
          });

          if (s.narration_model) {
            const hasModel = [...narrationSel.options].some(o => o.value === s.narration_model);
            if (hasModel) {
              narrationSel.value = s.narration_model;
            } else {
              const opt = document.createElement("option");
              opt.value = s.narration_model;
              opt.textContent = `${s.narration_model} ${t('settings.narrationModel.savedSuffix')}`;
              narrationSel.appendChild(opt);
              narrationSel.value = s.narration_model;
            }
          }

          if (!allowedNarrationModels.length) {
            if (!narrationSel.options.length) {
              const savedNarr = (s.narration_model || "").trim();
              if (savedNarr) {
                const opt = document.createElement("option");
                opt.value = savedNarr;
                opt.textContent = `${savedNarr} ${t('settings.narrationModel.savedSuffix')}`;
                narrationSel.appendChild(opt);
                narrationSel.value = savedNarr;
              } else {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = t('settings.narrationModel.enterKey');
                opt.disabled = true;
                opt.selected = true;
                narrationSel.appendChild(opt);
              }
            }
            narrationSel.setAttribute("disabled", "true");
            narrationSel.title = t('settings.narrationModel.disabledTitle');
          }

          if (allowedNarrationModels.length) {
            narrationSel.removeAttribute("disabled");
            narrationSel.title = "";
          }
        }
      } catch (e) {
        alert(t('alerts.modelsFetchFailed'));
      }

      const keyInput = $("setKey");
      if (keyInput) keyInput.value = typeof s.gemini_api_key === 'string' ? s.gemini_api_key : '';
      const grokKeyInput = $("setGrokKey");
      if (grokKeyInput) grokKeyInput.value = typeof s.grok_api_key === 'string' ? s.grok_api_key : '';
      const openaiKeyInput = $("setOpenAIKey");
      if (openaiKeyInput) openaiKeyInput.value = typeof s.openai_api_key === 'string' ? s.openai_api_key : '';
      const elevenKeyInput = $("setElevenKey");
      if (elevenKeyInput) {
        elevenKeyInput.value = typeof s.elevenlabs_api_key === 'string' ? s.elevenlabs_api_key : '';
      }
      const shareEl = $("shareUrl");
      if (shareEl) {
        const scheme = window.location.protocol === "https:" ? "https" : "http";
        const portSuffix = window.location.port ? `:${window.location.port}` : "";
        shareEl.textContent = `${scheme}://<your-public-ip-or-domain>${portSuffix}/`;
        try {
          const pubUrl = await (await fetch("/api/public_url")).json();
          if (pubUrl && pubUrl.url) {
            shareEl.textContent = pubUrl.url;
          }
        } catch (err) {
          // Fallback placeholder remains visible
        }
      }
      showModal('settingsBack');
    } finally {
      stopButtonCountdown('btnSettings');
    }
  }
  $("btnSettings").onclick = openSettings;
  $("btnCloseSettings").onclick = () => {
    hideModal('settingsBack');
  };
  bindVideoLengthControls();
  initializeWorldStylePicker();
  const worldStyleSelect = $('setWorld');
  if (worldStyleSelect) {
    worldStyleSelect.addEventListener('change', (ev) => {
      updateWorldPickerDisplay(ev.target.value);
      updateWorldMenuSelection(ev.target.value);
    });
  }
  const customWorldInputLive = $('setWorldCustom');
  if (customWorldInputLive) {
    customWorldInputLive.addEventListener('input', () => {
      const currentSelect = $('setWorld');
      if (currentSelect && normalizeWorldStyleValue(currentSelect.value) === normalizeWorldStyleValue(CUSTOM_WORLD_VALUE)) {
        updateWorldPickerDisplay(currentSelect.value);
      }
    });
  }
  $("btnSaveSettings").onclick = async () => {
    const worldSelectCurrent = $("setWorld");
    const customWorldInput = $("setWorldCustom");
    let worldStyleValue = DEFAULT_WORLD_STYLE;
    if (worldSelectCurrent) {
      if (worldSelectCurrent.value === CUSTOM_WORLD_VALUE) {
        const customValue = customWorldInput ? customWorldInput.value.trim() : '';
        worldStyleValue = customValue || DEFAULT_WORLD_STYLE;
      } else if (worldSelectCurrent.value) {
        worldStyleValue = worldSelectCurrent.value;
      }
    }
    const body = {
      world_style: worldStyleValue,
      difficulty: $("setDiff").value,
      thinking_mode: $("setThinking").value,
      text_model: $("setTextModel").value,
      image_model: $("setImageModel").value,
      video_model: $("setVideoModel").value,
    };
    const videoLengthInput = $("setVideoLength");
    if (videoLengthInput) {
      body.video_duration_seconds = clampVideoLength(videoLengthInput.value);
    }
    const historyToggle = $("setHistorySummary");
    if (historyToggle) {
      body.history_mode = historyToggle.checked ? 'summary' : 'full';
    }
    const fxSaverToggle = $("setFxSaver");
    const nextFxSaver = fxSaverToggle ? !!fxSaverToggle.checked : false;
    const narrationSel = $("setNarrationModel");
    if (narrationSel && !narrationSel.disabled) {
      const narrationVal = narrationSel.value.trim();
      if (narrationVal) body.narration_model = narrationVal;
    }
    const keyVal = $("setKey").value.trim();
    if (keyVal) body.gemini_api_key = keyVal;
    const grokKeyInput = $("setGrokKey");
    if (grokKeyInput) {
      const grokKeyVal = grokKeyInput.value.trim();
      if (grokKeyVal) body.grok_api_key = grokKeyVal;
    }
    const openaiKeyInput = $("setOpenAIKey");
    if (openaiKeyInput) {
      const openaiKeyVal = openaiKeyInput.value.trim();
      if (openaiKeyVal) body.openai_api_key = openaiKeyVal;
    }
    const elevenKeyInput = $("setElevenKey");
    if (elevenKeyInput) {
      const elevenKeyVal = elevenKeyInput.value.trim();
      if (elevenKeyVal) body.elevenlabs_api_key = elevenKeyVal;
    }
    const resp = await fetch("/api/settings", {
      method: "PUT",
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(body)
    });
    if (!resp.ok) { alert(t('alerts.settingsSaveFailed')); return; }
    applyFxSaver(nextFxSaver, { persist: true });
    hideModal('settingsBack');
  };

  const languageSelect = $('languageSelect');
  if (languageSelect) {
    languageSelect.addEventListener('change', (ev) => {
      setLanguage(ev.target.value, { persist: true, apply: true, notify: true });
    });
  }

  function formatDevInfoBlock(value) {
    if (value == null) return t('devInfo.empty');
    if (typeof value === 'object') {
      const isArray = Array.isArray(value);
      const isEmptyArray = isArray && value.length === 0;
      const isEmptyObject = !isArray && Object.keys(value).length === 0;
      if (isEmptyArray || isEmptyObject) {
        return t('devInfo.empty');
      }
      try {
        return JSON.stringify(value, null, 2);
      } catch (err) {
        return t('devInfo.empty');
      }
    }
    const text = String(value).trim();
    return text ? text : t('devInfo.empty');
  }

  // Developer info should surface just the parsed API JSON payload
  function extractResponseJson(snapshot) {
    if (!snapshot || typeof snapshot !== 'object') return null;
    if (Object.prototype.hasOwnProperty.call(snapshot, 'json')) {
      return snapshot.json;
    }
    return null;
  }

  function renderDeveloperInfoModal(payload) {
    const historyMode = String(((payload && payload.history_mode) || 'full')).toLowerCase();
    const includeTurnDetail = historyMode === 'summary';

    const assignBlock = (
      element,
      primaryValue,
      turnValue,
      primaryHeadingKey,
      turnHeadingKey
    ) => {
      if (!element) return;
      const primaryText = formatDevInfoBlock(primaryValue);
      const turnText = formatDevInfoBlock(turnValue);
      const primaryIsEmpty = primaryText === t('devInfo.empty');
      const turnIsEmpty = turnText === t('devInfo.empty');
      const blocks = [];
      const primaryHeading = primaryHeadingKey ? t(primaryHeadingKey) : '';
      const turnHeading = turnHeadingKey ? t(turnHeadingKey) : '';

      const withHeading = (heading, text) => {
        if (!text) return text;
        return heading ? `${heading}\n${text}` : text;
      };

      if (!primaryIsEmpty) {
        blocks.push(withHeading(primaryHeading, primaryText));
      }

      if (includeTurnDetail && !turnIsEmpty) {
        blocks.push(withHeading(turnHeading, turnText));
      } else if (!includeTurnDetail && primaryIsEmpty && !turnIsEmpty && blocks.length === 0) {
        blocks.push(withHeading(turnHeading, turnText));
      }

      if (!blocks.length) {
        blocks.push(withHeading(primaryHeading, primaryText));
      }

      element.textContent = blocks.join('\n\n');
    };

    assignBlock(
      $("devInfoRequest"),
      payload && payload.request,
      payload && payload.turn_request,
      includeTurnDetail ? 'devInfo.summaryRequestHeading' : null,
      includeTurnDetail ? 'devInfo.turnRequestHeading' : null
    );

    assignBlock(
      $("devInfoResponse"),
      extractResponseJson(payload && payload.response),
      extractResponseJson(payload && payload.turn_response),
      includeTurnDetail ? 'devInfo.summaryResponseHeading' : null,
      includeTurnDetail ? 'devInfo.turnResponseHeading' : null
    );
  }

  const devInfoModal = $("devInfoBack");
  const btnDevInfo = $("btnDevInfo");
  if (btnDevInfo && devInfoModal) {
    btnDevInfo.addEventListener('click', async () => {
      try {
        const resp = await fetch('/api/dev/text_inspect');
        if (!resp.ok) throw new Error('status');
        const data = await resp.json();
        renderDeveloperInfoModal(data || {});
        showModal('devInfoBack');
      } catch (err) {
        alert(t('devInfo.fetchError'));
      }
    });
  }
  const btnCloseDevInfo = $("btnCloseDevInfo");
  if (btnCloseDevInfo && devInfoModal) {
    btnCloseDevInfo.addEventListener('click', () => {
      hideModal('devInfoBack');
    });
  }

  $("btnStats").onclick = () => {
    if (state.lastPublic) {
      updateStats(state.lastPublic.token_usage);
    }
    showModal('statsBack');
  };
  $("btnCloseStats").onclick = () => {
    hideModal('statsBack');
  };

  $("btnStatsText").onclick = () => {
    if (state.lastPublic) {
      updateStats(state.lastPublic.token_usage);
    }
    showModal('statsTextBack');
  };
  $("btnCloseStatsText").onclick = () => {
    hideModal('statsTextBack');
  };

  $("btnStatsImage").onclick = () => {
    if (state.lastPublic) {
      updateStats(state.lastPublic.token_usage);
    }
    showModal('statsImageBack');
  };
  $("btnCloseStatsImage").onclick = () => {
    hideModal('statsImageBack');
  };

  $("btnStatsVideo").onclick = () => {
    if (state.lastPublic) {
      updateStats(state.lastPublic.token_usage);
    }
    showModal('statsVideoBack');
  };
  $("btnCloseStatsVideo").onclick = () => {
    hideModal('statsVideoBack');
  };

  $("btnStatsNarration").onclick = () => {
    if (state.lastPublic) {
      updateStats(state.lastPublic.token_usage);
    }
    showModal('statsNarrationBack');
  };
  $("btnCloseStatsNarration").onclick = () => {
    hideModal('statsNarrationBack');
  };

  const narrationButton = $("btnNarration");
  if (narrationButton) {
    if (narrationButton.title) {
      narrationButton.title = `${narrationButton.title} (Alt+N)`;
    }
    syncNarrationToggle(state.autoTtsEnabled);
    narrationButton.addEventListener("click", async () => {
      if (!state.playerId || !state.playerToken) {
        alert(t('alerts.joinControl'));
        return;
      }
      const nextState = !state.autoTtsEnabled;
      narrationButton.setAttribute("disabled", "true");
      try {
        const resp = await fetch("/api/tts_toggle", {
          method: "POST",
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ player_id: state.playerId, token: state.playerToken, enabled: nextState }),
        });
        if (!resp.ok) {
          await handleActionError(resp, 'alerts.toggleNarrationFailed');
          return;
        }
        const result = await resp.json();
        syncNarrationToggle(result && result.auto_tts_enabled);
      } catch (err) {
        const message = err && err.message ? err.message : err;
        alert(t('alerts.toggleNarrationFailedDetail', { message }));
      } finally {
        narrationButton.removeAttribute("disabled");
        narrationButton.disabled = !state.playerId;
      }
    });
  }

  // Join
  const enterButton = $("btnEnter");
  const joinNameInput = $("name");
  const joinBackgroundInput = $("background");
  const submitJoin = async () => {
    const rawName = joinNameInput ? joinNameInput.value : "";
    const rawBackground = joinBackgroundInput ? joinBackgroundInput.value : "";
    const nameVal = rawName || "Hephaest";
    const backgroundVal = rawBackground || "Wizard";
    rememberJoinInputs(nameVal, backgroundVal);
    setJoinWaiting(true);
    startButtonCountdown('btnEnter', (seconds) => t('join.countdown', { seconds }));
    updateJoinStatus('');
    const body = { name: nameVal, background: backgroundVal, language: state.language };
    let resp;
    try {
      resp = await fetch("/api/join", {
        method:"POST",
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(body)
      });
    } catch (err) {
      setJoinWaiting(false);
      updateJoinStatus("");
      alert(t('alerts.joinFailedDetail', { message: err.message }));
      return;
    }
    if (!resp.ok) {
      setJoinWaiting(false);
      updateJoinStatus("");
      const errorText = await resp.text();
      alert(t('alerts.joinFailedDetail', { message: errorText }));
      return;
    }
    const { player_id, auth_token } = await resp.json();
    const normalizedId = normalizeId(player_id) || player_id;
    state.playerId = normalizedId;
    state.playerToken = auth_token;
    state.playerName = nameVal;
    state.playerBackground = backgroundVal;
    state.pendingJoin = true;
    syncNarrationToggle(state.autoTtsEnabled);
    persistPlayerSession({
      id: normalizedId,
      token: auth_token,
      name: nameVal,
      background: backgroundVal,
      pending: true,
    });
    updateJoinStatus('');
    showJoinView();
    connectWS();
  };
  if (joinNameInput) {
    joinNameInput.addEventListener("input", () => {
      rememberJoinInputs(joinNameInput.value, joinBackgroundInput ? joinBackgroundInput.value : "");
    });
  }
  if (joinBackgroundInput) {
    joinBackgroundInput.addEventListener("input", () => {
      rememberJoinInputs(joinNameInput ? joinNameInput.value : "", joinBackgroundInput.value);
    });
    joinBackgroundInput.addEventListener("keydown", async (ev) => {
      if (ev.key === "Enter" && (ev.ctrlKey || ev.metaKey)) {
        ev.preventDefault();
        if (enterButton && !enterButton.disabled) {
          await submitJoin();
        }
      }
    });
  }
  if (enterButton) {
    enterButton.addEventListener("click", submitJoin);
  }

  // Actions
  const actionBox = $("action");
  const submitButton = $("btnSubmit");
  const ACTION_AUTO_SUBMIT_DELAY_MS = 1500;
  const ACTION_AUTO_SUBMIT_RETRY_MS = 250;
  let actionAutoSubmitTimer = null;
  let actionSubmitInFlight = false;
  let actionDirtySinceSubmit = false;
  let lastSubmittedAction = { text: '', turn: null };
  const clearActionAutoSubmitTimer = () => {
    if (actionAutoSubmitTimer) {
      window.clearTimeout(actionAutoSubmitTimer);
      actionAutoSubmitTimer = null;
    }
  };
  const submitAction = async (options = {}) => {
    const force = Boolean(options.force);
    if (!state.playerId || !state.playerToken || !actionBox) return false;
    if (actionSubmitInFlight) return false;
    const txt = actionBox.value.trim();
    if (!txt) return false;
    if (!force && !actionDirtySinceSubmit) return false;
    const currentTurn = Number.isFinite(state.currentTurn) ? state.currentTurn : null;
    if (!force && lastSubmittedAction.turn === currentTurn && lastSubmittedAction.text === txt) {
      return false;
    }
    clearActionAutoSubmitTimer();
    actionSubmitInFlight = true;
    let resp;
    try {
      resp = await fetch("/api/submit", {
        method:"POST",
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          player_id: state.playerId,
          token: state.playerToken,
          text: txt,
          language: state.language,
        })
      });
      if (!resp.ok) {
        await handleActionError(resp, 'alerts.submitFailed');
        return false;
      }
      lastSubmittedAction = { text: txt, turn: currentTurn };
      actionDirtySinceSubmit = false;
      return true;
    } catch (err) {
      const message = err && err.message ? err.message : err;
      alert(t('alerts.submitFailedDetail', { message }));
      return false;
    } finally {
      actionSubmitInFlight = false;
    }
  };
  const triggerAutoSubmit = () => {
    if (!actionBox || !actionBox.value.trim()) {
      actionAutoSubmitTimer = null;
      return;
    }
    if (actionSubmitInFlight) {
      actionAutoSubmitTimer = window.setTimeout(triggerAutoSubmit, ACTION_AUTO_SUBMIT_RETRY_MS);
      return;
    }
    actionAutoSubmitTimer = null;
    submitAction();
  };
  const scheduleAutoSubmit = () => {
    if (!actionBox) return;
    clearActionAutoSubmitTimer();
    const currentValue = actionBox.value;
    const trimmed = currentValue.trim();
    if (!trimmed) {
      actionDirtySinceSubmit = false;
      return;
    }
    const currentTurn = Number.isFinite(state.currentTurn) ? state.currentTurn : null;
    const isNewContent = lastSubmittedAction.turn !== currentTurn || lastSubmittedAction.text !== trimmed;
    actionDirtySinceSubmit = isNewContent;
    if (!isNewContent) return;
    actionAutoSubmitTimer = window.setTimeout(triggerAutoSubmit, ACTION_AUTO_SUBMIT_DELAY_MS);
  };
  if (submitButton) {
    submitButton.onclick = (ev) => {
      if (ev && typeof ev.preventDefault === 'function') {
        ev.preventDefault();
      }
      submitAction({ force: true });
    };
  }
  if (actionBox) {
    actionBox.addEventListener("input", scheduleAutoSubmit);
    actionBox.addEventListener("blur", () => {
      submitAction();
    });
    actionBox.addEventListener("keydown", async (ev) => {
      if (ev.key === "Enter" && (ev.ctrlKey || ev.metaKey)) {
        ev.preventDefault();
        clearActionAutoSubmitTimer();
        const didSubmit = await submitAction({ force: true });
        if (didSubmit) {
          const btnNextTurn = $("btnNextTurn");
          if (btnNextTurn) btnNextTurn.click();
        }
      } else if (ev.key === "Escape") {
        clearActionAutoSubmitTimer();
      }
    });
  }
  $("btnNextTurn").onclick = async () => {
    if (!state.playerId || !state.playerToken) return;
    startButtonCountdown('btnNextTurn', (seconds) => t('game.advanceCountdown', { seconds }));
    let resp;
    try {
      resp = await fetch("/api/next_turn", {
        method:"POST",
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          player_id: state.playerId,
          token: state.playerToken,
          language: state.language,
        })
      });
      if (!resp.ok) {
        await handleActionError(resp, 'alerts.nextTurnFailed');
        return;
      }
    } catch (err) {
      const message = err && err.message ? err.message : err;
      alert(t('alerts.nextTurnFailedDetail', { message }));
    } finally {
      stopButtonCountdown('btnNextTurn');
    }
  };
  const imageButton = $("btnCreateImage");
  if (imageButton) {
    if (imageButton.title) {
      imageButton.title = `${imageButton.title} (Alt+I)`;
    }
    syncSceneImageToggle(state.autoImageEnabled);
    imageButton.addEventListener("click", async () => {
      if (!state.playerId || !state.playerToken) {
        alert(t('alerts.joinControlImage'));
        return;
      }
      const nextState = !state.autoImageEnabled;
      imageButton.setAttribute("disabled", "true");
      try {
        const resp = await fetch("/api/image_toggle", {
          method: "POST",
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            player_id: state.playerId,
            token: state.playerToken,
            enabled: nextState,
          }),
        });
        if (!resp.ok) {
          await handleActionError(resp, 'alerts.toggleImageFailed');
          return;
        }
        const result = await resp.json();
        if (result && Object.prototype.hasOwnProperty.call(result, 'auto_image_enabled')) {
          syncSceneImageToggle(result.auto_image_enabled);
        } else {
          syncSceneImageToggle(nextState);
        }
        if (result && Object.prototype.hasOwnProperty.call(result, 'auto_video_enabled')) {
          syncSceneVideoToggle(result.auto_video_enabled);
        } else if (nextState) {
          syncSceneVideoToggle(false);
        }
      } catch (err) {
        const message = err && err.message ? err.message : err;
        alert(t('alerts.toggleImageFailedDetail', { message }));
      } finally {
        const busy = Boolean(state.lock && state.lock.active);
        if (!busy) {
          imageButton.removeAttribute("disabled");
        }
        imageButton.disabled = !state.playerId || Boolean(state.lock && state.lock.active);
      }
    });
  }

  const animateImageButton = $("btnAnimateImage");
  if (animateImageButton) {
    animateImageButton.addEventListener("click", async () => {
      if (!state.playerId || !state.playerToken) {
        alert(t('alerts.joinControlImage'));
        return;
      }
      animateImageButton.setAttribute("disabled", "true");
      startButtonCountdown('btnAnimateImage', (seconds) => t('common.workingCountdown', { seconds }));
      try {
        const resp = await fetch("/api/animate_scene", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            player_id: state.playerId,
            token: state.playerToken,
          }),
        });
        if (!resp.ok) {
          await handleActionError(resp, 'alerts.animateFailed');
          return;
        }
        await resp.json().catch(() => null);
      } catch (err) {
        const message = err && err.message ? err.message : err;
        alert(t('alerts.animateFailedDetail', { message }));
      } finally {
        stopButtonCountdown('btnAnimateImage');
        const busy = Boolean(state.lock && state.lock.active);
        if (!busy) {
          animateImageButton.removeAttribute('disabled');
          animateImageButton.setAttribute('title', t('sidebar.animateImageTitle'));
        }
        animateImageButton.disabled = !state.playerId || Boolean(state.lock && state.lock.active);
      }
    });
  }

  const animateButton = $("btnAnimateScene");
  if (animateButton) {
    syncSceneVideoToggle(state.autoVideoEnabled);
    animateButton.addEventListener("click", async () => {
      if (!state.playerId || !state.playerToken) {
        alert(t('alerts.joinControlImage'));
        return;
      }
      const nextState = !state.autoVideoEnabled;
      animateButton.setAttribute("disabled", "true");
      try {
        const resp = await fetch("/api/video_toggle", {
          method: "POST",
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            player_id: state.playerId,
            token: state.playerToken,
            enabled: nextState,
          }),
        });
        if (!resp.ok) {
          await handleActionError(resp, 'alerts.toggleVideoFailed');
          return;
        }
        const result = await resp.json();
        if (result && Object.prototype.hasOwnProperty.call(result, 'auto_video_enabled')) {
          syncSceneVideoToggle(result.auto_video_enabled);
        } else {
          syncSceneVideoToggle(nextState);
        }
        if (result && Object.prototype.hasOwnProperty.call(result, 'auto_image_enabled')) {
          syncSceneImageToggle(result.auto_image_enabled);
        } else if (nextState) {
          syncSceneImageToggle(false);
        }
      } catch (err) {
        const message = err && err.message ? err.message : err;
        alert(t('alerts.toggleVideoFailedDetail', { message }));
      } finally {
        const busy = Boolean(state.lock && state.lock.active);
        if (!busy) {
          animateButton.removeAttribute('disabled');
        }
        animateButton.disabled = !state.playerId || Boolean(state.lock && state.lock.active);
      }
    });
  }

  document.addEventListener('keydown', (ev) => {
    if (ev.key === "Escape") {
      if (closeOpenModals()) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      return;
    }

    if (ev.repeat) return;
    if (!ev.altKey || ev.ctrlKey || ev.metaKey) return;

    const key = (ev.key || '').toLowerCase();
    if (key === 'n') {
      const button = $("btnNarration");
      if (button && !button.disabled) {
        ev.preventDefault();
        button.click();
      }
    } else if (key === 'i') {
      const button = $("btnCreateImage");
      if (button && !button.disabled) {
        ev.preventDefault();
        button.click();
      }
    }
  });

  async function requestPortrait(buttonEl) {
    if (!state.playerId || !state.playerToken) return;
    if (buttonEl) {
      buttonEl.dataset.clickable = "false";
      buttonEl.onclick = null;
    }
    let resp;
    try {
      resp = await fetch("/api/create_portrait", {
        method: "POST",
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ player_id: state.playerId, token: state.playerToken }),
      });
    } catch (err) {
      if (buttonEl && !(state.lock && state.lock.active)) {
        updatePortraitButtonState(buttonEl, Boolean(state.lock && state.lock.active));
      }
      alert(t('alerts.portraitFailedDetail', { message: err.message }));
      return;
    }
    if (!resp.ok) {
      if (buttonEl && !(state.lock && state.lock.active)) {
        updatePortraitButtonState(buttonEl, Boolean(state.lock && state.lock.active));
      }
      await handleActionError(resp, 'alerts.portraitFailed');
    }
  }

  function handleNarrationAudio(data) {
    if (!data || typeof data.audio_base64 !== 'string' || !data.audio_base64) return;
    if (!state.autoTtsEnabled) return;
    const format = typeof data.format === 'string' ? data.format.toLowerCase() : '';
    let mime = 'audio/mpeg';
    if (format.startsWith('opus')) {
      mime = 'audio/ogg; codecs=opus';
    } else if (format.startsWith('pcm')) {
      mime = 'audio/wav';
    } else if (format.startsWith('ulaw') || format.startsWith('alaw')) {
      mime = 'audio/basic';
    }
    const src = `data:${mime};base64,${data.audio_base64}`;
    if (narrationState.current) {
      try { narrationState.current.pause(); } catch (err) { /* ignore */ }
      narrationState.current.src = '';
      narrationState.current = null;
    }
    const audio = new Audio(src);
    audio.preload = 'auto';
    audio.autoplay = true;
    audio.onended = () => {
      if (narrationState.current === audio) {
        narrationState.current = null;
      }
    };
    audio.onpause = () => {
      if (!audio.ended && narrationState.current === audio) {
        narrationState.current = null;
      }
    };
    narrationState.current = audio;
    hideSystemNotice('error');
    const playPromise = audio.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch((err) => {
        console.warn('Narration playback was blocked by the browser.', err);
      });
    }
  }

  function handleNarrationError(data) {
    const raw = data && typeof data.message === 'string' ? data.message.trim() : '';
    const severity = data && typeof data.severity === 'string' ? data.severity : 'error';
    const message = raw || 'ElevenLabs narration failed.';
    showSystemNotice(message, severity === 'error' ? 'error' : 'info');
  }

  // WebSocket
  let ws;
  function connectWS() {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
      try { ws.close(); } catch (err) { /* ignore */ }
    }
    const url = new URL(location.origin.replace(/^http/,"ws") + "/ws");
    if (state.playerId && state.playerToken) {
      url.searchParams.set("player_id", state.playerId);
      url.searchParams.set("auth_token", state.playerToken);
    }
    ws = new WebSocket(url);
    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.event === "state") renderPublic(msg.data);
      else if (msg.event === "tts_audio") handleNarrationAudio(msg.data);
      else if (msg.event === "tts_error") handleNarrationError(msg.data);
      else if (msg.event === "private") renderPrivate(msg.data);
      else if (msg.event === "announce") console.log(msg.data.message);
    };
    ws.onclose = () => {
      // Try reconnecting silently after a delay
      setTimeout(connectWS, 2000);
    };
  }
  // Renderers
  function renderPublic(s) {
    const previousPublic = state.lastPublic;
    state.lastPublic = s;
    const serverLanguage = (s && typeof s.language === 'string') ? s.language : null;
    if (serverLanguage && SUPPORTED_LANGUAGES.includes(serverLanguage)) {
      if (serverLanguage !== state.language) {
        setLanguage(serverLanguage, { persist: true, apply: true });
      }
      lastLanguageSync = serverLanguage;
    }
    state.autoImageEnabled = Boolean(s && s.auto_image_enabled);
    state.autoVideoEnabled = Boolean(s && s.auto_video_enabled);
    syncNarrationToggle(Boolean(s && s.auto_tts_enabled));
    refreshJoinGuidance();
    if (state.pendingJoin === true && state.playerId && state.playerToken) {
      handleJoinState(true);
    }
    const turnVal = typeof s.turn_index === 'number' ? s.turn_index : 0;
    if (Number.isFinite(turnVal)) {
      updateTurnHeader(turnVal);
    }
    const previousTurn = typeof previousPublic?.turn_index === 'number' ? previousPublic.turn_index : null;
    const turnChanged = Number.isFinite(turnVal) && previousTurn !== turnVal;
    const completedTurn = Number.isFinite(turnVal) ? turnVal - 1 : null;
    const hasCompletedTurn = typeof completedTurn === 'number' && completedTurn >= 0;
    const historyRecords = Array.isArray(s.history) ? s.history : [];
    renderNarrativeHistory(historyRecords);
    const narrativeEl = $("narrative");
    if (narrativeEl) {
      const previousTextRaw = typeof previousPublic?.current_narrative === 'string' ? previousPublic.current_narrative : '';
      const previousTrimmed = previousTextRaw.trim();
      const text = typeof s.current_narrative === 'string' ? s.current_narrative : '';
      const trimmedText = text.trim();
      const hasText = trimmedText.length > 0;
      const targetTurn = hasCompletedTurn ? completedTurn : null;

      if (targetTurn != null) {
        const block = getNarrativeBlock(targetTurn, hasText);
        if (block) {
          block.textContent = hasText ? text : '—';
        }
      } else if (!narrativeEl.dataset.historyReady) {
        narrativeEl.textContent = hasText ? text : '—';
      }

      const textChanged = trimmedText !== previousTrimmed;
      if (turnChanged) {
        narrativeScrollState.lastTurnScrolled = null;
      }
      if ((turnChanged || textChanged) && hasText) {
        const shouldStick = narrativeIsPinnedToTop(narrativeEl);
        if (shouldStick) {
          const alreadyScrolled = hasCompletedTurn && narrativeScrollState.lastTurnScrolled === targetTurn;
          if (!alreadyScrolled) {
            scrollNarrativeToTop();
            narrativeScrollState.lastTurnScrolled = hasCompletedTurn ? targetTurn : null;
          }
        }
      }
    }
    if (turnChanged && actionBox) {
      actionBox.value = '';
      actionDirtySinceSubmit = false;
      lastSubmittedAction = { text: '', turn: Number.isFinite(turnVal) ? turnVal : null };
      clearActionAutoSubmitTimer();
    }
    updateStats(s.token_usage);
    setLockBanner(s.lock || {active:false});
    syncSceneImageToggle(state.autoImageEnabled);
    syncSceneVideoToggle(state.autoVideoEnabled);

    const pl = $("players");
    pl.innerHTML = "";
    hidePortraitPreview();
    const lockActive = Boolean(state.lock && state.lock.active);
    const activeLeaveIds = new Set();
    (s.players || []).forEach((p) => {
      const li = document.createElement("li");

      const main = document.createElement("div");
      main.className = "player-main";

      const portraitBtn = document.createElement("button");
      portraitBtn.type = "button";
      portraitBtn.className = "player-portrait";
      const playerId = normalizeId(p.id);
      const playerIdAttr = playerId || '';
      portraitBtn.dataset.playerId = playerIdAttr;
      if (playerId) {
        activeLeaveIds.add(playerId);
      }
      const isYou = Boolean(state.playerId && playerId && state.playerId === playerId);
      portraitBtn.dataset.owned = isYou ? "true" : "false";
      portraitBtn.dataset.pending = p.pending_join ? "true" : "false";
      const portrait = p.portrait || null;
      const initial = (p.name || "?").trim().charAt(0).toUpperCase() || "?";
      if (portrait && portrait.data_url) {
        portraitBtn.style.backgroundImage = `url(${portrait.data_url})`;
        portraitBtn.classList.add("has-image");
        portraitBtn.textContent = "";
        portraitBtn.dataset.hasImage = "true";
        portraitBtn.dataset.portraitUrl = portrait.data_url;
        portraitBtn.dataset.portraitPrompt = portrait.prompt || "";
        const turnaround = portrait.turnaround || null;
        portraitBtn.dataset.turnaroundUrl = (turnaround && turnaround.data_url) ? turnaround.data_url : "";
        portraitBtn.dataset.turnaroundPrompt = (turnaround && turnaround.prompt) ? turnaround.prompt : "";
        portraitBtn.addEventListener("mouseenter", (ev) => showPortraitPreview({
          src: portraitBtn.dataset.portraitUrl,
          prompt: portraitBtn.dataset.portraitPrompt,
          turnaroundSrc: portraitBtn.dataset.turnaroundUrl,
          turnaroundPrompt: portraitBtn.dataset.turnaroundPrompt,
        }, ev, portraitBtn));
        portraitBtn.addEventListener("mousemove", (ev) => updatePortraitPreviewPosition(ev, portraitBtn));
        portraitBtn.addEventListener("mouseleave", hidePortraitPreview);
        portraitBtn.addEventListener("focus", () => showPortraitPreview({
          src: portraitBtn.dataset.portraitUrl,
          prompt: portraitBtn.dataset.portraitPrompt,
          turnaroundSrc: portraitBtn.dataset.turnaroundUrl,
          turnaroundPrompt: portraitBtn.dataset.turnaroundPrompt,
        }, null, portraitBtn));
        portraitBtn.addEventListener("blur", hidePortraitPreview);
      } else {
        portraitBtn.style.backgroundImage = "";
        portraitBtn.classList.remove("has-image");
        portraitBtn.textContent = initial;
        portraitBtn.dataset.hasImage = "false";
        portraitBtn.dataset.portraitUrl = "";
        portraitBtn.dataset.portraitPrompt = "";
        portraitBtn.dataset.turnaroundUrl = "";
        portraitBtn.dataset.turnaroundPrompt = "";
        portraitBtn.addEventListener("mouseenter", hidePortraitPreview);
        portraitBtn.addEventListener("mouseleave", hidePortraitPreview);
        portraitBtn.addEventListener("focus", hidePortraitPreview);
        portraitBtn.addEventListener("blur", hidePortraitPreview);
      }
      const portraitName = p.name || t('game.playerFallback');
      portraitBtn.setAttribute('aria-label', t('game.portrait.ariaLabel', { name: portraitName }));
      updatePortraitButtonState(portraitBtn, lockActive);

      const nameWrap = document.createElement("div");
      nameWrap.className = "player-name";

      const nameRow = document.createElement("div");
      nameRow.className = "player-name-row";

      const name = document.createElement("div");
      name.className = "player-name-main";
      name.textContent = p.name;
      nameRow.appendChild(name);

      const status = document.createElement("span");
      status.textContent = p.status_word || "—";
      status.className = `${pillClass(p.status_word)} player-status`;
      nameRow.appendChild(status);

      const submissionText = typeof p.submission === 'string' ? p.submission.trim() : '';
      const actionEl = document.createElement("div");
      actionEl.className = "player-action";
      if (submissionText) {
        const prefix = t('game.playerAction.prefix');
        actionEl.textContent = `${prefix}${submissionText}`;
        actionEl.classList.add("has-submission");
      } else {
        actionEl.textContent = t('game.playerAction.none');
      }
      nameRow.appendChild(actionEl);

      nameWrap.appendChild(nameRow);

      const cls = document.createElement("div");
      cls.className = "player-class";
      cls.textContent = p.cls || "—";
      nameWrap.appendChild(cls);

      const tags = document.createElement("div");
      tags.className = "player-tags";
      if (p.pending_join) {
        const joinTag = document.createElement("span");
        joinTag.className = "pill warn";
        joinTag.textContent = t('game.playerTag.joining');
        tags.appendChild(joinTag);
      }
      if (shouldShowLeaveNotice(playerId, p.pending_leave)) {
        const leaveTag = document.createElement("span");
        leaveTag.className = "pill bad";
        leaveTag.textContent = t('game.playerTag.departing');
        tags.appendChild(leaveTag);
      }
      if (tags.children.length) {
        nameWrap.appendChild(tags);
      }

      main.appendChild(portraitBtn);
      main.appendChild(nameWrap);

      li.appendChild(main);
      pl.appendChild(li);
    });

    const youId = state.lastPrivate && state.lastPrivate.you ? normalizeId(state.lastPrivate.you.id) : null;
    if (youId) {
      activeLeaveIds.add(youId);
    }
    pruneLeaveNoticeState(activeLeaveIds);

    const img = $("scene");
    const videoEl = $("sceneVideo");
    const animateBtn = $("btnAnimateScene");
    const animateImageBtn = $("btnAnimateImage");
    const sceneImage = s.image && typeof s.image === 'object' ? s.image : null;
    const sceneVideo = s.video && typeof s.video === 'object' ? s.video : null;
    const hasImage = Boolean(sceneImage && sceneImage.data_url);
    const hasVideo = Boolean(sceneVideo && sceneVideo.url);

    if (hasVideo && videoEl) {
      const baseUrl = sceneVideo.url;
      const stampValue = Number.isFinite(sceneVideo.updated_at) ? Math.floor(sceneVideo.updated_at) : Date.now();
      const needsUpdate = videoEl.dataset.baseUrl !== baseUrl || videoEl.dataset.cacheToken !== String(stampValue);
      if (needsUpdate) {
        const joiner = baseUrl.includes('?') ? '&' : '?';
        videoEl.src = `${baseUrl}${joiner}v=${stampValue}`;
        videoEl.dataset.baseUrl = baseUrl;
        videoEl.dataset.cacheToken = String(stampValue);
        state.sceneVideoUserPaused = false;
        delete videoEl.dataset.userPaused;
      }
      if (sceneImage && sceneImage.data_url) {
        videoEl.poster = sceneImage.data_url;
      } else if (videoEl.poster) {
        videoEl.removeAttribute('poster');
      }
      const autoplayMuted = videoEl.dataset.autoplayMuted === 'true';
      if (!autoplayMuted) {
        videoEl.defaultMuted = false;
        videoEl.muted = false;
        if (typeof videoEl.volume === 'number') {
          videoEl.volume = 1;
        }
        if (videoEl.hasAttribute('muted')) {
          videoEl.removeAttribute('muted');
        }
      }
      videoEl.title = sceneVideo.prompt || '';
      videoEl.classList.remove('hidden');
      videoEl.style.display = '';
      ensureSceneVideoAutoplays(videoEl);
      state.sceneVideoUrl = baseUrl;
      state.sceneVideoToken = String(stampValue);
      if (img) {
        img.removeAttribute('src');
        img.title = '';
        img.style.display = 'none';
      }
    } else {
      state.sceneVideoUrl = null;
      state.sceneVideoToken = null;
      state.sceneVideoUserPaused = false;
      if (videoEl) {
        try {
          ignoreSceneVideoPause = true;
          videoEl.pause();
        } catch (err) {
          /* ignore */
        } finally {
          ignoreSceneVideoPause = false;
        }
        videoEl.removeAttribute('src');
        videoEl.removeAttribute('poster');
        delete videoEl.dataset.baseUrl;
        delete videoEl.dataset.cacheToken;
        delete videoEl.dataset.autoplayMuted;
        delete videoEl.dataset.userPaused;
        if (typeof videoEl.load === 'function') {
          videoEl.load();
        }
        videoEl.classList.add('hidden');
        videoEl.style.display = 'none';
      }
      if (img) {
        if (hasImage) {
          img.src = sceneImage.data_url;
          img.title = sceneImage.prompt || '';
          img.style.display = '';
        } else {
          img.removeAttribute('src');
          img.title = '';
          img.style.display = 'none';
        }
      }
    }

    if (animateImageBtn) {
      const shouldShow = hasImage;
      if (shouldShow) {
        animateImageBtn.classList.remove('hidden');
        animateImageBtn.style.display = '';
        animateImageBtn.setAttribute('title', t('sidebar.animateImageTitle'));
        if (!state.lock || !state.lock.active) {
          animateImageBtn.removeAttribute('disabled');
        }
        if (!animateImageBtn.dataset.defaultLabel) {
          const label = (animateImageBtn.textContent || '').trim();
          if (label) {
            animateImageBtn.dataset.defaultLabel = label;
          }
        }
      } else {
        animateImageBtn.classList.add('hidden');
        animateImageBtn.style.display = 'none';
        stopButtonCountdown('btnAnimateImage');
      }
    }

    if (narrativeSizer) {
      narrativeSizer.resize();
    }
  }

  function renderPrivate(data) {
    const y = data && data.you ? data.you : {};
    if (!y || !y.id) {
      state.lastPrivate = null;
      if (state.youHighlights && typeof state.youHighlights === 'object') {
        state.youHighlights.abilities = resetHighlightBucket(state.youHighlights.abilities);
        state.youHighlights.inventory = resetHighlightBucket(state.youHighlights.inventory);
        state.youHighlights.conditions = resetHighlightBucket(state.youHighlights.conditions);
        state.youHighlights.turn = Number.isFinite(state.currentTurn) ? state.currentTurn : 0;
      }
      if (state.youRemovals && typeof state.youRemovals === 'object') {
        state.youRemovals.abilities = resetHighlightBucket(state.youRemovals.abilities);
        state.youRemovals.inventory = resetHighlightBucket(state.youRemovals.inventory);
        state.youRemovals.conditions = resetHighlightBucket(state.youRemovals.conditions);
        state.youRemovals.turn = Number.isFinite(state.currentTurn) ? state.currentTurn : 0;
      }
      return;
    }
    const highlights = ensureHighlightStateTurn(state.currentTurn);
    const removals = ensureRemovalStateTurn(state.currentTurn);
    pruneRemovalEntries(removals.abilities, y.abilities, abilityKey);
    pruneRemovalEntries(removals.inventory, y.inventory, textEntryKey);
    pruneRemovalEntries(removals.conditions, y.conditions, textEntryKey);
    const prevPrivate = state.lastPrivate;
    const prevYou = prevPrivate && prevPrivate.you ? prevPrivate.you : null;
    const abilityAdds = prevYou ? computeAddedCounts(prevYou.abilities, y.abilities, abilityKey) : new Map();
    const inventoryAdds = prevYou ? computeAddedCounts(prevYou.inventory, y.inventory, textEntryKey) : new Map();
    const conditionAdds = prevYou ? computeAddedCounts(prevYou.conditions, y.conditions, textEntryKey) : new Map();
    const abilityRemoved = prevYou ? computeRemovedEntries(prevYou.abilities, y.abilities, abilityKey) : new Map();
    const inventoryRemoved = prevYou ? computeRemovedEntries(prevYou.inventory, y.inventory, textEntryKey) : new Map();
    const conditionRemoved = prevYou ? computeRemovedEntries(prevYou.conditions, y.conditions, textEntryKey) : new Map();
    mergeHighlightCounts(highlights.abilities, abilityAdds);
    mergeHighlightCounts(highlights.inventory, inventoryAdds);
    mergeHighlightCounts(highlights.conditions, conditionAdds);
    mergeRemovalEntries(removals.abilities, abilityRemoved);
    mergeRemovalEntries(removals.inventory, inventoryRemoved);
    mergeRemovalEntries(removals.conditions, conditionRemoved);
    const youId = normalizeId(y.id);
    if (!state.playerId && youId) {
      state.playerId = youId;
      syncNarrationToggle(state.autoTtsEnabled);
      syncSceneImageToggle(state.autoImageEnabled);
      syncSceneVideoToggle(state.autoVideoEnabled);
    }
    state.playerName = y.name || state.playerName || '';
    if (typeof y.pending_join === 'boolean') {
      handleJoinState(y.pending_join);
    }
    const youFlags = $("youFlags");
    if (youFlags) {
      youFlags.innerHTML = "";
      youFlags.style.display = "none";
      if (y.pending_join) {
        const joinTag = document.createElement("span");
        joinTag.className = "pill warn";
        joinTag.textContent = t('game.playerFlag.queued');
        youFlags.appendChild(joinTag);
      }
      if (shouldShowLeaveNotice(youId, y.pending_leave)) {
        const leaveTag = document.createElement("span");
        leaveTag.className = "pill bad";
        leaveTag.textContent = t('game.playerFlag.departing');
        youFlags.appendChild(leaveTag);
      }
      if (youFlags.children.length) {
        youFlags.style.display = "flex";
      }
    }
    renderAbilityList($("youAbilities"), y.abilities, cloneHighlightMap(highlights.abilities), cloneRemovalEntries(removals.abilities));
    renderInventoryList($("youInv"), y.inventory, cloneHighlightMap(highlights.inventory), cloneRemovalEntries(removals.inventory));
    renderConditionList($("youCond"), y.conditions, cloneHighlightMap(highlights.conditions), cloneRemovalEntries(removals.conditions));
    state.lastPrivate = data;
  }

  function updateStats(usage) {
    const usageData = usage || {};
    const last = usageData.last_turn || {};
    const session = usageData.session || {};
    const totals = usageData.totals || {};
    const breakdown = (totals && totals.breakdown) || {};
    const imageData = usageData.image || {};
    const imageLast = imageData.last || {};
    const imageSession = imageData.session || {};
    const videoData = usageData.video || {};
    const videoLast = videoData.last || {};
    const videoSession = videoData.session || {};
    const safeSet = (id, value) => {
      const el = $(id);
      if (el) el.textContent = value;
    };
    const formatParts = (src) => {
      const keys = ["input", "output", "thinking"];
      return keys.map((key) => {
        const val = src && src[key];
        return Number.isFinite(val) ? val.toLocaleString() : "—";
      }).join(" / ");
    };
    const formatTotal = (value) => Number.isFinite(value) ? value.toLocaleString() : "—";
    const formatCurrency = (value, precision = 4) => (
      Number.isFinite(value) ? `$${Number(value).toFixed(precision)}` : "—"
    );
    const formatSeconds = (value, fractionDigits = 2) => (
      Number.isFinite(value)
        ? Number(value).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: fractionDigits })
        : "—"
    );
    const formatNumber = (value) => (Number.isFinite(value) ? value.toLocaleString() : "—");
    const formatImageTypeCounts = (entries) => {
      const src = entries && typeof entries === 'object' ? entries : {};
      const scene = Number.isFinite(src.scene) ? src.scene : 0;
      const portrait = Number.isFinite(src.portrait) ? src.portrait : 0;
      const sceneLabel = t('stats.image.type.scene');
      const portraitLabel = t('stats.image.type.portrait');
      const baseParts = [`${sceneLabel}: ${scene}`, `${portraitLabel}: ${portrait}`];
      const extraParts = Object.entries(src)
        .filter(([key]) => key !== 'scene' && key !== 'portrait')
        .map(([key, val]) => {
          if (!Number.isFinite(val)) return null;
          const labelKey = `stats.image.type.${key}`;
          const label = TRANSLATIONS[labelKey] ? t(labelKey) : key;
          return `${label}: ${val}`;
        })
        .filter(Boolean);
      return [...baseParts, ...extraParts].join(', ');
    };

    const formatCredits = (value) => {
      if (Number.isFinite(value)) {
        const abs = Math.abs(value);
        const fractionDigits = abs >= 1000 ? 0 : abs >= 100 ? 1 : 2;
        return value.toLocaleString(undefined, { maximumFractionDigits: fractionDigits });
      }
      return "—";
    };

    safeSet("statsCostLast", formatCurrency(totals.last_usd));
    safeSet("statsCostSession", formatCurrency(totals.session_usd));
    safeSet("statsTextCostLast", formatCurrency(last.cost_usd));
    safeSet("statsTextCostSession", formatCurrency(session.cost_usd));
    safeSet("statsTextTokensLast", formatParts(last));
    safeSet("statsTextTokensSession", formatParts(session));
    safeSet("statsTextTokensLastTotal", formatTotal(last.total));
    safeSet("statsTextTokensSessionTotal", formatTotal(session.total));
    const tokensPerSec = Number.isFinite(last.tokens_per_sec)
      ? `${last.tokens_per_sec.toFixed(1)} ${t('stats.text.rateUnit')}`
      : "—";
    safeSet("statsTextRate", tokensPerSec);
    const reqVal = session.requests;
    safeSet("statsTextRequests", (reqVal === null || reqVal === undefined) ? "—" : `${reqVal}`);

    const imageTurnCostValue = Number.isFinite(breakdown.image_last_turn_usd)
      ? breakdown.image_last_turn_usd
      : null;
    safeSet("statsImageCostLast", formatCurrency(imageTurnCostValue));
    safeSet("statsImageCostSession", formatCurrency(imageSession.cost_usd));
    safeSet("statsImageModel", imageLast.model ? imageLast.model : "—");
    safeSet("statsImageCountSession", formatNumber(imageSession.images));

    const unitCost = formatCurrency(imageLast.usd_per_image, 3);
    const avgCost = Number.isFinite(imageSession.avg_usd_per_image)
      ? formatCurrency(imageSession.avg_usd_per_image, 3)
      : null;
    let unitLabel = unitCost;
    const avgPrefix = t('stats.image.avgPrefix');
    if (unitLabel === '—' && avgCost) {
      unitLabel = `${avgPrefix} ${avgCost}`;
    } else if (unitCost !== '—' && avgCost && unitCost !== avgCost) {
      unitLabel = `${unitCost} (${avgPrefix} ${avgCost})`;
    }
    safeSet("statsImageAvgCost", unitLabel);
    const turnCounts = formatImageTypeCounts((imageData.turn && imageData.turn.by_kind) || {});
    safeSet("statsImageTurnCounts", turnCounts);
    const sessionCounts = formatImageTypeCounts(imageSession.by_kind);
    safeSet("statsImageSessionCounts", sessionCounts);

    const videoTurnCostValue = Number.isFinite(breakdown.video_last_turn_usd)
      ? breakdown.video_last_turn_usd
      : videoLast.cost_usd;
    safeSet("statsVideoCostLast", formatCurrency(videoTurnCostValue));
    safeSet("statsVideoCostSession", formatCurrency(videoSession.cost_usd));
    let videoModelLabel = videoLast.model || "";
    if (videoModelLabel) {
      const tier = videoLast.tier;
      if (tier) {
        videoModelLabel = `${videoModelLabel} (${tier})`;
      }
    } else {
      videoModelLabel = "—";
    }
    safeSet("statsVideoModel", videoModelLabel);
    safeSet("statsVideoSecondsLast", formatSeconds(videoLast.seconds));
    safeSet("statsVideoSecondsSession", formatSeconds(videoSession.seconds));
    safeSet("statsVideoUsdPerSecond", formatCurrency(videoLast.usd_per_second, 4));
    safeSet("statsVideoAvgUsdPerSecond", formatCurrency(videoSession.avg_usd_per_second, 4));
    safeSet("statsVideoRequests", formatNumber(videoSession.requests));
    safeSet("statsVideoAvgSecondsPerRequest", formatSeconds(videoSession.avg_seconds_per_request));

    const narrationData = usageData.narration || {};
    const narrationLast = narrationData.last || {};
    const narrationSession = narrationData.session || {};
    safeSet("statsNarrationCostLast", formatCurrency(narrationLast.cost_usd));
    safeSet("statsNarrationCostSession", formatCurrency(narrationSession.cost_usd));

    safeSet("statsNarrationCharsLast", formatNumber(narrationLast.characters));
    safeSet("statsNarrationCharsSession", formatNumber(narrationSession.characters));

    safeSet("statsNarrationCreditsLast", formatCredits(narrationLast.credits));
    safeSet("statsNarrationCreditsSession", formatCredits(narrationSession.credits));

    safeSet("statsNarrationModel", narrationLast.model || "—");
    safeSet("statsNarrationVoice", narrationLast.voice_id || "—");
    safeSet("statsNarrationRequests", formatNumber(narrationSession.requests));
    const remainingCredits = narrationSession.remaining_credits ?? narrationLast.remaining_credits;
    safeSet("statsNarrationCreditsRemaining", formatNumber(remainingCredits));
  }

  // Enable drag-and-drop reordering for all panes (with dynamic lanes)
  function enablePaneReorder() {
    const board = document.querySelector('[data-pane-board]');
    if (!board) return;

    const laneSelector = '.col[data-pane-group]';
    const baseLaneIds = new Set(['main', 'sidebar']);
    const maxLanes = 4;
    const draggingClass = 'dragging';
    const storageKey = 'paneLayout:v3';
    let dropZone = null;

    const getLanes = () => [...board.querySelectorAll(laneSelector)];
    const getCards = () => [...board.querySelectorAll('.card[data-pane-id]')];

    const canStore = (() => {
      try {
        const key = '__pane_test';
        localStorage.setItem(key, '1');
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        return false;
      }
    })();

    if (canStore) {
      ['paneOrder:main', 'paneOrder:sidebar'].forEach((oldKey) => {
        try {
          localStorage.removeItem(oldKey);
        } catch (err) {
          /* ignore removal failures */
        }
      });
    }

    const uniqueLaneId = (() => {
      let counter = 0;
      return () => {
        counter += 1;
        return `lane-${Date.now()}-${counter}`;
      };
    })();

    const clearTargets = () => {
      getLanes().forEach((lane) => lane.classList.remove('drag-target'));
      if (dropZone) dropZone.classList.remove('drag-target');
    };

    const cleanupEmptyLanes = () => {
      getLanes().forEach((lane) => {
        const id = lane.dataset.paneGroup;
        if (!id) return;
        if (!baseLaneIds.has(id) && !lane.querySelector('.card[data-pane-id]')) {
          lane.remove();
        }
      });
    };

    const persist = () => {
      cleanupEmptyLanes();
      if (!canStore) return;
      const layout = getLanes().map((lane) => ({
        id: lane.dataset.paneGroup,
        panes: [...lane.querySelectorAll('.card[data-pane-id]')].map((card) => card.dataset.paneId),
      }));
      try {
        localStorage.setItem(storageKey, JSON.stringify({ lanes: layout }));
      } catch (err) {
        /* ignore storage failures */
      }
    };

    const getDragAfterElement = (lane, y) => {
      const cards = [...lane.querySelectorAll('.card[data-pane-id]:not(.' + draggingClass + ')')];
      return cards.reduce(
        (closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
          }
          return closest;
        },
        { offset: Number.NEGATIVE_INFINITY, element: null }
      ).element;
    };

    const attachLaneHandlers = (lane) => {
      if (!lane || lane.dataset.laneBound) return;
      lane.dataset.laneBound = 'true';
      lane.addEventListener('dragover', (ev) => {
        const dragging = document.querySelector('.' + draggingClass);
        if (!dragging) return;
        ev.preventDefault();
        const after = getDragAfterElement(lane, ev.clientY);
        if (after) lane.insertBefore(dragging, after);
        else lane.appendChild(dragging);
        lane.classList.add('drag-target');
      });
      lane.addEventListener('dragleave', (ev) => {
        const next = ev.relatedTarget;
        if (!next || !lane.contains(next)) {
          lane.classList.remove('drag-target');
        }
      });
      lane.addEventListener('drop', (ev) => {
        ev.preventDefault();
        lane.classList.remove('drag-target');
        persist();
      });
    };

    const createLaneElement = (id) => {
      const lane = document.createElement('section');
      lane.className = 'col';
      lane.dataset.paneGroup = id;
      lane.style.display = '';
      board.insertBefore(lane, dropZone && dropZone.parentElement === board ? dropZone : null);
      attachLaneHandlers(lane);
      return lane;
    };

    const showDropZone = () => {
      if (getLanes().length >= maxLanes) return;
      if (!dropZone) {
        dropZone = document.createElement('div');
        dropZone.className = 'col lane-drop';
        dropZone.dataset.newLane = 'true';
        dropZone.textContent = t('game.dropZone');
        dropZone.addEventListener('dragover', (ev) => {
          const dragging = document.querySelector('.' + draggingClass);
          if (!dragging) return;
          ev.preventDefault();
          dropZone.classList.add('drag-target');
        });
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('drag-target');
        });
        dropZone.addEventListener('drop', (ev) => {
          ev.preventDefault();
          dropZone.classList.remove('drag-target');
          const dragging = document.querySelector('.' + draggingClass);
          if (!dragging) return;
          const newLane = createLaneElement(uniqueLaneId());
          newLane.appendChild(dragging);
          persist();
        });
      }
      if (!dropZone.parentElement) {
        board.appendChild(dropZone);
      }
    };

    const hideDropZone = () => {
      if (dropZone && dropZone.parentElement) {
        dropZone.classList.remove('drag-target');
        board.removeChild(dropZone);
      }
    };

    const attachCardHandlers = (card) => {
      if (!card || card.dataset.paneBound) return;
      card.dataset.paneBound = 'true';
      card.setAttribute('draggable', 'true');
      card.addEventListener('dragstart', (ev) => {
        card.classList.add(draggingClass);
        if (ev.dataTransfer) {
          ev.dataTransfer.effectAllowed = 'move';
          ev.dataTransfer.setData('text/plain', card.dataset.paneId || '');
        }
        showDropZone();
      });
      card.addEventListener('dragend', () => {
        card.classList.remove(draggingClass);
        hideDropZone();
        clearTargets();
        persist();
      });
    };

    const restore = () => {
      if (!canStore) return;
      const raw = localStorage.getItem(storageKey);
      if (!raw) return;
      let saved;
      try {
        saved = JSON.parse(raw);
      } catch (err) {
        return;
      }
      if (!saved || !Array.isArray(saved.lanes)) return;

      const cards = new Map(getCards().map((card) => [card.dataset.paneId, card]));
      const placed = new Set();
      const lanesById = new Map(getLanes().map((lane) => [lane.dataset.paneGroup, lane]));

      saved.lanes.slice(0, maxLanes).forEach((laneData) => {
        if (!laneData || !laneData.id) return;
        let lane = lanesById.get(laneData.id);
        if (!lane) {
          lane = createLaneElement(laneData.id);
          lanesById.set(laneData.id, lane);
        } else {
          board.appendChild(lane);
        }
        laneData.panes.forEach((paneId) => {
          const card = cards.get(paneId);
          if (card) {
            lane.appendChild(card);
            placed.add(paneId);
          }
        });
      });

      cards.forEach((card, paneId) => {
        if (!placed.has(paneId)) {
          let targetLane = lanesById.get('main');
          if (!targetLane) {
            targetLane = getLanes()[0] || createLaneElement('main');
            lanesById.set(targetLane.dataset.paneGroup, targetLane);
          }
          targetLane.appendChild(card);
        }
      });

      cleanupEmptyLanes();
    };

    getCards().forEach(attachCardHandlers);
    getLanes().forEach(attachLaneHandlers);
    restore();
    persist();
  }

  (function () {
    function px(n) {
      return `${Math.max(0, Math.floor(n))}px`;
    }

    function sixLineMin(el) {
      const cs = getComputedStyle(el);
      let lh = parseFloat(cs.lineHeight);
      if (!Number.isFinite(lh)) {
        lh = (parseFloat(cs.fontSize) || 16) * 1.4;
      }
      return Math.ceil(lh * 6);
    }

    function findColumn(el) {
      while (el && el !== document.body) {
        if (el.classList && el.classList.contains('col') && el.hasAttribute('data-pane-group')) {
          return el;
        }
        el = el.parentElement;
      }
      return null;
    }

    function getRowGap(col) {
      const cs = getComputedStyle(col);
      return parseFloat(cs.rowGap || cs.gap) || 0;
    }

    function resizeScenario() {
      if (document.body.classList.contains('join-screen')) return;

      const narrativeEl = $('narrative');
      if (!narrativeEl) return;

      const narrativeCard = narrativeEl.closest('.card[data-pane-id="narrative"]');
      const col = narrativeCard ? findColumn(narrativeCard) : null;
      const wrap = document.querySelector('.wrap');
      if (!narrativeCard || !col || !wrap) return;

      const wrapCS = getComputedStyle(wrap);
      const padBottom = parseFloat(wrapCS.paddingBottom) || 0;
      const colRect = col.getBoundingClientRect();
      let available = window.innerHeight - colRect.top - padBottom;
      available = Math.max(0, available);

      const cards = Array.from(col.querySelectorAll('.card[data-pane-id]'));
      const gap = getRowGap(col);
      const gapsTotal = Math.max(cards.length - 1, 0) * gap;

      let otherHeights = 0;
      for (const c of cards) {
        if (c === narrativeCard) continue;
        otherHeights += c.getBoundingClientRect().height;
      }

      const cardRect = narrativeCard.getBoundingClientRect();
      const narrativeRect = narrativeEl.getBoundingClientRect();
      const chrome = cardRect.height - narrativeRect.height;

      const minH = sixLineMin(narrativeEl);
      let target = available - otherHeights - gapsTotal - chrome;
      target = Math.max(minH, target);

      narrativeEl.style.minHeight = px(minH);
      narrativeEl.style.maxHeight = px(target);
      narrativeEl.style.height = px(target);
    }

    narrativeSizer = {
      _initialized: false,
      _resizeObserver: null,
      _mutationObserver: null,
      resize: resizeScenario,
      init() {
        resizeScenario();
        if (narrativeSizer._initialized) return;
        narrativeSizer._initialized = true;

        window.addEventListener('resize', resizeScenario);
        window.addEventListener('orientationchange', resizeScenario);

        if (typeof ResizeObserver === 'function') {
          const ro = new ResizeObserver(resizeScenario);
          narrativeSizer._resizeObserver = ro;
          ['body', '.wrap', '#gameView'].forEach((sel) => {
            const el = document.querySelector(sel);
            if (el) ro.observe(el);
          });
        }

        if (typeof MutationObserver === 'function') {
          const mo = new MutationObserver(resizeScenario);
          narrativeSizer._mutationObserver = mo;
          const board = document.querySelector('main.wrap');
          if (board) {
            mo.observe(board, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class'] });
          }
        }
      },
      resizeNow: resizeScenario,
    };

    window.narrativeSizer = narrativeSizer;
  })();

  enablePaneReorder();

  if (narrativeSizer) {
    narrativeSizer.init();
  }

  function initClient() {
    setupSceneVideoPersistence();
    loadJoinBackgrounds();
    state.joinBackgroundUrl = pickJoinBackground();
    applyJoinBackground(state.joinBackgroundUrl);
    showJoinView();
    setJoinWaiting(false);
    updateJoinStatus("");
    loadJoinMusicLibrary();
    const stored = getStoredPlayer();
    if (stored) {
      applyStoredJoinInputs(stored);
      if (typeof stored.name === 'string') {
        state.playerName = stored.name;
      }
      if (typeof stored.background === 'string') {
        state.playerBackground = stored.background;
      }
      if (stored.id && stored.token) {
        const restoredId = normalizeId(stored.id);
        state.playerId = restoredId || stored.id;
        state.playerToken = stored.token;
        state.pendingJoin = typeof stored.pending === 'boolean' ? stored.pending : null;
        syncNarrationToggle(state.autoTtsEnabled);
        if (stored.pending === true) {
          setJoinWaiting(true);
          updateJoinStatus('', { key: 'join.status.waitingQueued' });
          showJoinView();
        } else if (stored.pending === false) {
          updateJoinStatus("");
          setJoinWaiting(false);
          showGameView();
        } else {
          setJoinWaiting(true);
          updateJoinStatus('', { key: 'join.status.restoring' });
        }
      }
    }
    connectWS();
    fetch("/api/state")
      .then((r) => r.json())
      .then(renderPublic)
      .catch(() => {});
  }

  initClient();
</script>
</body>
</html>
